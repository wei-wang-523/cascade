package edu.nyu.cascade.fds;

import java.util.Arrays;
import java.util.List;

import com.google.common.base.Function;
import com.google.common.collect.Lists;

import edu.nyu.cascade.fds.impl.StateVariableImpl;
import edu.nyu.cascade.ir.expr.DualExpression;
import edu.nyu.cascade.ir.expr.DualExpressionFactory;
import edu.nyu.cascade.ir.expr.DualExpressionImpl;
import edu.nyu.cascade.ir.expr.ExpressionFactoryException;
import edu.nyu.cascade.ir.type.IRType;
import edu.nyu.cascade.prover.type.ArrayType;
import edu.nyu.cascade.prover.type.Type;

public class DualStateExpressionFactory<Int, Bool, StateT extends Type<StateT>>
    extends
    DualExpressionFactory<Int,Bool,StateT>
    implements
    TemporalExpressionEncoding<DualExpression<Int,Bool>, DualExpression<Int,Bool>, StateT> 
{
  public static <Int, Bool, StateT extends Type<StateT>> DualStateExpressionFactory<Int, Bool, StateT> of(
      TemporalExpressionEncoding<Int, Bool, StateT> f) {
    return new DualStateExpressionFactory<Int, Bool, StateT>(f);
  }
  
  TemporalExpressionEncoding<Int,Bool,StateT> exprFactory;
  
  protected DualStateExpressionFactory(TemporalExpressionEncoding<Int,Bool,StateT> exprFactory) {
    super(exprFactory);
    this.exprFactory = exprFactory;
  }

  @Override
  public void addAtPredicate(String label,
      final Function<DualExpression<Int, Bool>,DualExpression<Int, Bool>> atPred) {
    exprFactory.addAtPredicate(label, new Function<Int, Bool>() {
      @Override
      public Bool apply(Int from) {
        return atPred.apply(DualExpressionImpl.fromInteger(exprFactory, from)).castToBoolean();
      }
    });
  }

  @Override
  public void addAtPredicate(String label, DualExpression<Int, Bool> atPred)
      throws ExpressionFactoryException {
    exprFactory.addAtPredicate(label, atPred.castToBoolean());
  }

  @Override
  public StateVariable<?> addSourceVariable(String qName, IRType type)
      throws ExpressionFactoryException {
    return exprFactory.addSourceVariable(qName,type);
  }

  @Override
  public DualExpressionImpl<Int, Bool> and(DualExpression<Int, Bool>... conjuncts)
      throws ExpressionFactoryException {
    return and(Lists.newArrayList(conjuncts));
  }

  @Override
  public DualExpressionImpl<Int, Bool> and(
      Iterable<? extends DualExpression<Int, Bool>> conjuncts)
      throws ExpressionFactoryException {
    List<Bool> conj2 = Lists.newArrayList();
    for( DualExpression<Int,Bool> c : conjuncts ) {
      conj2.add( c.castToBoolean() );
    }
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.and(conj2));
  }

  @Override
  public DualExpressionImpl<Int, Bool> atPredicate(String firstLabel, String... otherLabels) {
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.atPredicate(
        firstLabel, otherLabels));
  }

  @Override
  public DualExpression<Int, Bool> atPredicate(String label,
      DualExpression<Int, Bool> index) {
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.atPredicate(label,index.castToInteger()));
  }

  @Override
  public StateVariable<?> bindingForSourceVar(String qName) {
    return exprFactory.bindingForSourceVar(qName);
  }

  public StateVariableImpl<?> constant(String name, IRType t, boolean fresh)
      throws ExpressionFactoryException {
    return exprFactory.constant(name, t, fresh);
  }

  @Override
  public <T extends Type<T>> StateProperty distinct(
      Iterable<? extends StateExpression<T>> exprs) {
    return exprFactory.distinct(exprs);
  }

  @Override
  public DualExpression<Int, Bool> forall(DualExpression<Int, Bool> var,
      DualExpression<Int, Bool> p) throws ExpressionFactoryException {
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.forall(var
        .castToInteger(), p.castToBoolean()));
  }

  @Override
  public TemporalExpressionEncoding<Int, Bool, StateT> getInnerFactory() {
    return exprFactory;
  }

  @Override
  public DualExpression<Int, Bool> negate(DualExpression<Int, Bool> arg)
      throws ExpressionFactoryException {
    return DualExpressionImpl.fromInteger(exprFactory, exprFactory.negate(arg.castToInteger()));
  }

  @Override
  public DualExpressionImpl<Int, Bool> or(DualExpression<Int, Bool>... disjuncts)
      throws ExpressionFactoryException {
    return or(Lists.newArrayList(disjuncts));
  }

  @Override
  public DualExpressionImpl<Int, Bool> or(
      Iterable<? extends DualExpression<Int, Bool>> disjuncts)
      throws ExpressionFactoryException {
    List<Bool> disj2 = Lists.newArrayList();
    for( DualExpression<Int,Bool> d : disjuncts ) {
      disj2.add( d.castToBoolean() );
    }
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.or(disj2));
  }

  @Override
  public DualExpression<Int, Bool> plus(DualExpression<Int, Bool>... args)
      throws ExpressionFactoryException {
    return plus(Arrays.asList(args));
  }

  @Override
  public DualExpression<Int, Bool> plus(
      Iterable<? extends DualExpression<Int, Bool>> args)
      throws ExpressionFactoryException {
    return DualExpressionImpl.fromInteger(exprFactory, exprFactory
        .plus(DualExpressionImpl.castToIntegers(args)));
  }

  @Override
  public DualExpressionImpl<Int, Bool> preserved(
      Iterable<? extends StateVariable> xs) throws ExpressionFactoryException {
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.preserved(xs));
  }

  @Override
  public String sourceVarForBinding(StateVariable<?> var) {
    return exprFactory.sourceVarForBinding(var);
  }

  @Override
  public IRType typeForSourceVar(String qName) {
    return exprFactory.typeForSourceVar(qName);
  }

  @Override
  public <I extends Type<I>, E extends Type<E>> StateExpression<ArrayType<I, E>> updateArray(
      StateExpression<ArrayType<I, E>> array, StateExpression<I> index,
      StateExpression<E> newValue) {
    return exprFactory.updateArray(array, index, newValue);
  }

  @Override
  public DualExpression<Int, Bool> atPredicate(
      DualExpression<Int, Bool> index, String firstLabel,
      String... otherLabels) throws ExpressionFactoryException {
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.atPredicate(
        index.castToInteger(), firstLabel, otherLabels));
  }
}