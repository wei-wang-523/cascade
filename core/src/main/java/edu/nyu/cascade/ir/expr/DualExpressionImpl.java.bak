package edu.nyu.cascade.ir.expr;

import com.google.common.base.Function;
import com.google.common.collect.ComputationException;
import com.google.common.collect.Iterables;

import edu.nyu.cascade.util.ConversionException;
import edu.nyu.cascade.util.ConversionStrategy;
import edu.nyu.cascade.util.ConvertibleValue;
import edu.nyu.cascade.util.ConvertibleValues;

public class DualExpressionImpl<Int, Bool> implements DualExpression<Int, Bool> {
  private static <Int, Bool> ConversionStrategy<Int, Bool> factoryToStrategy(
      final ExpressionEncoding<Int, Bool, ?> factory) {
    return new ConversionStrategy<Int, Bool>() {
      @Override
      public Bool leftToRight(Int l) throws ConversionException {
        try {
          return factory.castToBoolean(l);
        } catch (ExpressionFactoryException e) {
          throw new ConversionException(e);
        }
      }

      @Override
      public Int rightToLeft(Bool r) throws ConversionException {
        try {
          return factory.castToInteger(r);
        } catch (ExpressionFactoryException e) {
          throw new ConversionException(e);
        }
      }
    };
  }

  public static <Int, Bool> DualExpressionImpl<Int, Bool> fromBoolean(
      ExpressionEncoding<Int, Bool, ?> factory, Bool b) {
    return new DualExpressionImpl<Int, Bool>(factory, null, b, false);
  }

  public static <Int, Bool> DualExpressionImpl<Int, Bool> fromInteger(
      ExpressionEncoding<Int, Bool, ?> factory, Int a) {
    return new DualExpressionImpl<Int, Bool>(factory, a, null, true);
  }

  public static <Int, Bool> Iterable<Bool> castToBooleans(
      Iterable<? extends DualExpression<Int, Bool>> xs) {
    return Iterables.transform(xs,new Function<DualExpression<Int, Bool>,Bool>() {
      @Override
      public Bool apply(DualExpression<Int, Bool> arg0) {
        try {
          return arg0.castToBoolean();
        } catch (ExpressionFactoryException e) {
          throw new ComputationException(e);
        }
      }
    });
  }
  
  public static <Int, Bool> Iterable<Int> castToIntegers(
      Iterable<? extends DualExpression<Int, Bool>> xs) {
    return Iterables.transform(xs,new Function<DualExpression<Int, Bool>,Int>() {
      @Override
      public Int apply(DualExpression<Int, Bool> arg0) {
        try {
          return arg0.castToInteger();
        } catch (ExpressionFactoryException e) {
          throw new ComputationException(e);
        }
      }
    });
  }
  
  private final ConvertibleValue<Int, Bool> val;

  private DualExpressionImpl(ExpressionEncoding<Int, Bool, ?> factory, Int a,
      Bool b, boolean asInt) {
    if (asInt) {
      val = ConvertibleValues.fromLeft(factoryToStrategy(factory), a);
    } else {
      val = ConvertibleValues.fromRight(factoryToStrategy(factory), b);
    }
  }

  public Bool castToBoolean() throws ExpressionFactoryException {
    try {
      return val.right();
    } catch (ConversionException e) {
      throw new ExpressionFactoryException(e);
    }
  }

  public Int castToInteger() throws ExpressionFactoryException {
    try {
      return val.left();
    } catch (ConversionException e) {
      throw new ExpressionFactoryException(e);
    }
  }
  
  public String toString() {
    return val.toString();
  }
}
