package edu.nyu.cascade.ir.expr;

import java.util.List;

import com.google.common.collect.ImmutableSet;

import edu.nyu.cascade.ir.expr.ExpressionFactoryException.ThrowingFunction;
import edu.nyu.cascade.ir.type.IRType;
import edu.nyu.cascade.prover.Expression;
import edu.nyu.cascade.prover.ExpressionManager;
import edu.nyu.cascade.prover.type.ArrayType;
import edu.nyu.cascade.prover.type.BooleanType;
import edu.nyu.cascade.prover.type.Type;
import edu.nyu.cascade.util.IOUtils;

/**
 * An expression factory which automatically "dualizes" integer/boolean
 * expressions. I.e., it binds them to a common super-type and defers
 * conversions until a typed operator makes them necessary.
 * 
 * @param <Int>
 *          The type of integer expressions
 * @param <Bool>
 *          The type of boolean expressions
 * @param <StateT>
 *          The type of state variables (see IExpressionFactory)
 */

public class DualExpressionFactory<Expr,State>
    extends
    AbstractExpressionEncoding<DualExpression<Int, Bool>, DualExpression<Int, Bool>, StateT> {
  public static <Int, Bool, T extends Type<T>> DualExpressionFactory<Int, Bool, T> of(
      ExpressionEncoding<Int, Bool, T> exprFactory) {
    IOUtils.debug().pln("Creating DualExpressionFactory with: " + exprFactory);
    return new DualExpressionFactory<Int, Bool, T>(exprFactory);
  }

  private final ExpressionEncoding<Expr,State> exprFactory;

  // private final IDualExpressionStrategy<Int, Bool> dualExprStrategy;

  protected DualExpressionFactory(ExpressionEncoding<Expr,State> exprFactory) {
    super(exprFactory.getExpressionManager());
    this.exprFactory = exprFactory;
    // this.dualExprStrategy = dualExprStrategy;
  }

  @Override
  public DualExpression<Int, Bool> allocated(DualExpression<Int, Bool> ptr,
      DualExpression<Int, Bool> size) throws ExpressionFactoryException {
    return DualExpressionImpl.fromBoolean(exprFactory, exprFactory.allocated(ptr
        .castToInteger(), size.castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> and(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.and(lhs.castToBoolean(), rhs
        .castToBoolean()));
  }

  @Override
  public Expression<StateT> assign(Expression<StateT> state,
      DualExpression<Int, Bool> lval, DualExpression<Int, Bool> rval)
      throws ExpressionFactoryException {
    return exprFactory
        .assign(state, lval.castToInteger(), rval.castToInteger());
  }

  @Override
  public DualExpression<Int, Bool> bitwiseAnd(DualExpression<Int, Bool> a,
      DualExpression<Int, Bool> b) throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.bitwiseAnd(a.castToInteger(), b
        .castToInteger()));
  }

  private Iterable<Bool> booleansFromDuals(
      Iterable<? extends DualExpression<Int, Bool>> duals)
      throws ExpressionFactoryException {
    return ExpressionFactoryException.wrapIterableTransformation(duals,
        new ThrowingFunction<DualExpression<Int, Bool>, Bool>() {
          @Override
          public Bool apply(DualExpression<Int, Bool> disj)
              throws ExpressionFactoryException {
            return disj.castToBoolean();
          }
        });
  }

  public DualExpression<Int, Bool> castToBoolean(
      DualExpression<Int, Bool> expr) throws ExpressionFactoryException {
    return expr;
  }

  public DualExpression<Int, Bool> castToInteger(
      DualExpression<Int, Bool> bool) throws ExpressionFactoryException {
    return bool;
  }

  /*
   * @Override public IDualExpression<Int, Bool> createBoolean(Node sourceNode,
   * boolean negated) throws ExpressionFactoryException { return
   * dualFromBoolean(exprFactory.createBoolean(sourceNode, negated)); }
   */

  @Override
  public DualExpression<Int, Bool> decr(DualExpression<Int, Bool> expr)
      throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.decr(expr.castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> deref(DualExpression<Int, Bool> e)
      throws ExpressionFactoryException {
    return DualExpressionImpl.fromInteger(exprFactory, exprFactory.deref(e
        .castToInteger()));
  }

  private DualExpression<Int, Bool> dualFromBoolean(Bool bool) {
    return DualExpressionImpl.fromBoolean(exprFactory, bool);
  }

  private DualExpression<Int, Bool> dualFromInteger(Int expr) {
    return DualExpressionImpl.fromInteger(exprFactory, expr);
  }

  @Override
  public DualExpression<Int, Bool> eq(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.eq(lhs.castToInteger(), rhs
        .castToInteger()));
  }

  @Override
  public Expression<BooleanType> evalBoolean(DualExpression<Int, Bool> e,
      Expression<StateT> state) throws ExpressionFactoryException {
    return exprFactory.evalBoolean(e.castToBoolean(), state);
  }

  @Override
  public DualExpression<Int, Bool> ff() throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.ff());
  }

  @Override
  public DualExpression<Int, Bool> functionCall(String name,
      List<DualExpression<Int, Bool>> args) throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.functionCall(name,
        integersFromDuals(args)));
  }

  @Override
  public ImmutableSet<? extends Expression<BooleanType>> getAssumptions()
      throws ExpressionFactoryException {
    return exprFactory.getAssumptions();
  }

  @Override
  public ExpressionManager getExpressionManager() {
    return exprFactory.getExpressionManager();
  }

  public ExpressionEncoding<Expr,State> getInnerFactory() {
    return exprFactory;
  }

  @Override
  public StateT getStateType() throws ExpressionFactoryException {
    return exprFactory.getStateType();
  }

  @Override
  public DualExpression<Int, Bool> greaterThan(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.greaterThan(lhs.castToInteger(), rhs
        .castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> greaterThanOrEqual(
      DualExpression<Int, Bool> lhs, DualExpression<Int, Bool> rhs)
      throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.greaterThanOrEqual(lhs.castToInteger(),
        rhs.castToInteger()));

  }

  @Override
  public DualExpression<Int, Bool> ifThenElse(DualExpression<Int, Bool> bool,
      DualExpression<Int, Bool> thenExpr, DualExpression<Int, Bool> elseExpr)
      throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.ifThenElse(bool.castToBoolean(),
        thenExpr.castToInteger(), elseExpr.castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> incr(DualExpression<Int, Bool> expr)
      throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.incr(expr.castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> integerConstant(int c)
      throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.integerConstant(c));

  }

  private Iterable<Int> integersFromDuals(
      Iterable<? extends DualExpression<Int, Bool>> duals)
      throws ExpressionFactoryException {
    return ExpressionFactoryException.wrapIterableTransformation(duals,
        new ThrowingFunction<DualExpression<Int, Bool>, Int>() {
          @Override
          public Int apply(DualExpression<Int, Bool> disj)
              throws ExpressionFactoryException {
            return disj.castToInteger();
          }
        });
  }

  @Override
  public DualExpression<Int, Bool> integerVar(String id, boolean fresh)
      throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.integerVar(id, true));
  }

  @Override
  public DualExpression<Int, Bool> lessThan(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.lessThan(lhs.castToInteger(), rhs
        .castToInteger()));

  }

  @Override
  public DualExpression<Int, Bool> lessThanOrEqual(
      DualExpression<Int, Bool> lhs, DualExpression<Int, Bool> rhs)
      throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.lessThanOrEqual(lhs.castToInteger(), rhs
        .castToInteger()));

  }

  /*
   * @Override public IDualExpression<Int, Bool> lval(Node sourceNode) throws
   * ExpressionFactoryException { return
   * dualFromInteger(exprFactory.lval(sourceNode)); }
   */

  @Override
  public DualExpression<Int, Bool> minus(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.minus(lhs.castToInteger(), rhs
        .castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> neq(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.neq(lhs.castToInteger(), rhs
        .castToInteger()));
  }

  @Override
  public DualExpression<Int, Bool> nor(
      Iterable<DualExpression<Int, Bool>> disjuncts)
      throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.nor(booleansFromDuals(disjuncts)));
  }

  @Override
  public DualExpression<Int, Bool> not(DualExpression<Int, Bool> b)
      throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.not(b.castToBoolean()));
  }

  @Override
  public DualExpression<Int, Bool> one() throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.one());
  }

  @Override
  public DualExpression<Int, Bool> or(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.or(lhs.castToBoolean(), rhs
        .castToBoolean()));
  }

  /*
   * @Override public IDualExpression<Int, Bool> parseIntegerExpression(Node
   * sourceNode) throws ExpressionFactoryException { return
   * dualFromInteger(exprFactory.parseIntegerExpression(sourceNode)); }
   */
  @Override
  public DualExpression<Int, Bool> plus(DualExpression<Int, Bool> lhs,
      DualExpression<Int, Bool> rhs) throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.plus(lhs.castToInteger(), rhs
        .castToInteger()));

  }

  @Override
  public DualExpression<Int, Bool> tt() throws ExpressionFactoryException {
    return dualFromBoolean(exprFactory.tt());
  }

  @Override
  public DualExpression<Int, Bool> unknown() throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.unknown());
  }

  @Override
  public DualExpression<Int, Bool> zero() throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.zero());
  }

  @Override
  public <I extends Type<I>, E extends Type<E>> DualExpression<Int, Bool> indexArray(
      Expression<ArrayType<I, E>> array,
      DualExpression<Int, Bool> index) throws ExpressionFactoryException {
    return dualFromInteger(exprFactory.indexArray(array, index.castToInteger()));
  }

  @Override
  public <I extends Type<I>, E extends Type<E>> DualExpression<Int, Bool> indexArray(
      Expression<ArrayType<I,E>> array,
      Iterable<? extends DualExpression<Int, Bool>> indices) {
    return dualFromInteger(exprFactory.indexArray(array, DualExpressionImpl
        .castToIntegers(indices)));
  }

  @Override
  public Type<?> type(IRType t) throws ExpressionFactoryException {
    return exprFactory.type(t);
  }

  @Override
  public Object variable(String name, IRType type, boolean fresh)
      throws ExpressionFactoryException {
    return exprFactory.variable(name, type, fresh);
  }
}
