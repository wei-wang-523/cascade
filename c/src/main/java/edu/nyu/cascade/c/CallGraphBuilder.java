package edu.nyu.cascade.c;

import java.util.Map;

import xtc.tree.GNode;
import xtc.tree.LineMarker;
import xtc.tree.Location;
import xtc.tree.Node;
import xtc.tree.Visitor;

import com.google.common.base.Preconditions;

import edu.nyu.cascade.ir.IRCallGraph;
import edu.nyu.cascade.ir.IRControlFlowGraph;
import edu.nyu.cascade.ir.IRVarInfo;
import edu.nyu.cascade.ir.SymbolTable;
import edu.nyu.cascade.ir.impl.CallGraph;
import edu.nyu.cascade.ir.impl.CallGraphNode;
import edu.nyu.cascade.util.IOUtils;
import edu.nyu.cascade.util.Preferences;
import edu.nyu.cascade.util.ReservedFunction;

/**
 * A Call Graph builder for ASTs generated by <code>edu.nyu.cascade.c.CParser</code>. A
 * typical client should just call <code>getCallGraph</code> to extract Call Graph from the
 * AST for a compilation unit.
 * 
 * <em>Note for implementers:</em> To add support for a parse rule Foo, add a
 * method <code>T visitFoo(Node n)</code>, where <code>T</code> is a type of
 * your choosing (or <code>void</code>). See the documentation for
 * <code>xtc.tree.Visitor</code> for more information.
 */
public class CallGraphBuilder extends Visitor {
  
  /**
   * Retrieve the Call Graph from the given parse tree, using the given symbol table
   * and expression manager.
   * 
   * @param symbolTable
   *          The symbol table to use for symbols defined and used in the parse
   *          tree.
   * @param cfgs 
   * @param ast
   *          A <code>edu.nyu.cascade.c.CParser</code> compilation unit AST
   *          node.
   * @return A <code>Map</code> from declaration nodes to Call Graph.
   */
  public static IRCallGraph getCallGraph(SymbolTable symbolTable, 
  		Map<Node, IRControlFlowGraph> cfgs, Node ast) {
    return (IRCallGraph) new CallGraphBuilder(symbolTable, cfgs).dispatch(ast);
  }
	
	/**
	 * Whether to treat <code>compoundStatement {...}</code> as a new scope in the 
	 * <code>symbolTable<code>; it's thanks to the <code>functionDefinition</code> 
	 * and <code>forStatement</code> -- these two kinds of nodes have the SCOPE 
	 * property, and we call <code>enterScope(node)</code> for these nodes.
	 * 
	 * E.g. <code>for(int i=0; i<10; i++) {...}</code>, if to call <code>enterScope()
	 * </code> in the compound statement inside the loop body {...}, the 
	 * initialized declarator <code>int i=0</code> will cause error, since the <code>
	 * symbolTable</code> under current scope doesn't include it.
	 */
	private boolean compoStmtAsScope;

	private final SymbolTable symbolTable;
	private final Map<Node, IRControlFlowGraph> cfgs;
	private CallGraph callGraph;
	private CallGraphNode currentFuncNode;
  
  private CallGraphBuilder(SymbolTable symbolTable, 
  		Map<Node, IRControlFlowGraph> cfgs) {
    this.symbolTable = symbolTable;
    this.cfgs = cfgs;
    compoStmtAsScope = true;
  }
  
  /** SymbolTable enters a nested scope. */
  private void enterScope(GNode node) {
  	Preconditions.checkArgument(symbolTable.hasScope(node));
    symbolTable.enterScope(node);
  }
  
  /** SymbolTable exit a nested scope. */
  private void exitScope() {
    symbolTable.setScope(symbolTable.getCurrentScope().getParent());
  }
  
  /**
   * Find function declare node
   * @param info
   * @return the function declare node
   */
  private Node findFuncDeclareNode (IRVarInfo info) {
  	Preconditions.checkArgument(info != null);
    Location funcDeclareLoc = info.getDeclarationNode().getLocation();
    
    final String funcFile = funcDeclareLoc.file;
    final int lineNum = funcDeclareLoc.line;
    for(Node node : cfgs.keySet()) {
    	Location loc = node.getLocation();
    	if(funcFile.equals(loc.file) && (lineNum == loc.line))
    		return node;
    }
    
    IOUtils.debug().pln("Cannot find the function declaration node for " + info.getName());
    return null;
  }
  
  @Override
  public Object unableToVisit(Node node) {
    return node;
  }

  /** Visit the specified translation unit. */
	public CallGraph visitTranslationUnit(GNode n) {
		callGraph = CallGraph.create();
	  for (Object o : n) {
	    dispatch((Node) o);
	  }
	  return callGraph;
	}

	public void visitAdditiveExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    dispatch(node.getNode(0));
    dispatch(node.getNode(2));
  }
  
  public void visitMultiplicativeExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    dispatch(node.getNode(0));
    dispatch(node.getNode(2));
  }

  public void visitAddressExpression(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitAssignmentExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(2));
  }

  public void visitBitwiseAndExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(1));
  }
  
  public void visitBitwiseOrExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(1));
  }

  public void visitCastExpression(GNode node) {
  	dispatch(node.getNode(1));
  }
  
  public void visitConditionalExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(1));
    dispatch(node.getNode(2));
  }

  public void visitCommaExpression(GNode node) {
    for(Object o : node) {
      dispatch((Node) o);
    }
  }
  
  public void visitCompoundStatement(GNode node) {
    if(!compoStmtAsScope) {
      compoStmtAsScope = true;
      for (Object o : node) {
        dispatch((Node) o);
      }
    } else {
    	assert(symbolTable.hasScope(node));
    	enterScope(node);
      for (Object o : node) {
        dispatch((Node) o);
      }
      exitScope();
    }
  }

  public void visitDeclaration(GNode node) {
    Node declarations = node.getNode(2);
    if (declarations != null) {
      for (Object o : declarations) {
        dispatch((Node) o);
      }
    }
  }

  public void visitEqualityExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(2));
  }

  public void visitExpressionList(GNode node) {
    for (Object elem : node) 	dispatch((Node) elem);
  }

  public void visitExpressionStatement(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitArrayDeclarator(GNode node) {
  	for(Object elem : node)
  		dispatch((Node) elem);
  }
  
  public void visitFunctionCall(GNode node) {
    Node funNode = node.getNode(0);
    Node argList = node.getNode(1);
    
    /* [chris 1/8/2010] FIXME: avoid a lookup on the function name, since it
     * will probably return null.
     */
    if( !funNode.hasName("PrimaryIdentifier") ) {
    	dispatch(funNode);
    }
    
    dispatch(argList);
    
    String funcName = funNode.getString(0);
    if(!ReservedFunction.Functions.contains(funcName)) {
    	IRVarInfo varInfo = symbolTable.lookup(funcName);
    	Node funcDeclNode = findFuncDeclareNode(varInfo);
    	CallGraphNode callerNode = CallGraphNode.create(funcDeclNode);
    	callGraph.addCallEdge(currentFuncNode, node, callerNode);
    }
  }

  public void visitDoStatement(GNode node) {
    Node test = node.getNode(1);
    Node body = node.getNode(0);

    dispatch(test);
    dispatch(body);
  }
  
  public void visitFunctionDefinition(GNode node) {
    /* Node is: FunctionDefinition(type modifiers, type signature (including
     * id), locals, body)
     */

    final GNode declarator = node.getGeneric(2);
    currentFuncNode = CallGraphNode.create(node);
    
    GNode parameters = CAnalyzer.getFunctionDeclarator(declarator).getGeneric(1);
    if( parameters != null ) {
      parameters = parameters.getGeneric(0);
    }
    
    /* FunctionDefiniion node has 'scope' property, here enter the scope
     * directly, ignore the following compoundStatement; it means no need
     * to enter scope there, set 'CompoStmtAsScope' as 'false'
     */
    enterScope(node);
    compoStmtAsScope = false;
    if (parameters != null) {
      for (Object o : parameters) {
        assert (o instanceof Node);
        assert (((Node) o).hasName("ParameterDeclaration"));
        /* Drill down to the actual declaration */
        dispatch(((Node) o).getNode(1));
      }
    }

    /* recurse on the function body */
    final GNode body = node.getGeneric(4);
    dispatch(body);
    exitScope();
  }

  public void visitGotoStatement(GNode node) {
    Node labelNode = node.getNode(1);
    dispatch(labelNode);
  }
  
  public void visitIfElseStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);
    Node elsePart = node.getNode(2);

    dispatch(test);
    dispatch(ifPart);
    dispatch(elsePart);
  }

  public void visitIfStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);

    dispatch(test);
    dispatch(ifPart);
  }

  public void visitIndirectionExpression(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitInitializedDeclarator(GNode node) {
    /* If there is an initializer, add as an assignment statement */
    Node varNode = node.getNode(1);
    dispatch(varNode);
    
    /* Assignment expression is included here, e.g. "int a = 1;" */
    if (node.get(4) instanceof Node) {
    	Node valNode = node.getNode(4);
    	dispatch(valNode);
    }
  }

  public void visitInitializerList(GNode node) {
    for (Object elem : node) 
    	dispatch((Node) elem);
  }

  public void visitInitializerListEntry(GNode node) {
  	for(Object elem : node)
  		dispatch((Node) elem);
  }

  public void visitLabeledStatement(GNode node) {
    Node label = node.getNode(0);
    Node stmt = node.getNode(1);
    if(label.hasName("CaseLabel")) {
      dispatch(label.getNode(0));
    }
    dispatch(stmt);
  }

  public void visitLogicalAndExpression(GNode node) {
    /* Deal with side-effects */
    dispatch(node.getNode(0));
    dispatch(node.getNode(1));
  }
  
  public void visitLogicalOrExpression(GNode node) {
    /* Deal with side-effects */
    dispatch(node.getNode(0));
    dispatch(node.getNode(1));
  }

  public void visitLogicalNegationExpression(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitSizeofExpression(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitTypeName(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitDirectComponentSelection(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitIndirectComponentSelection(GNode node) {
    dispatch(node.getNode(0));
  }
  
  public void visitPostdecrementExpression(GNode node) {
    dispatch(node.getNode(0));
  }
  
  public void visitPostincrementExpression(GNode node) {
  	dispatch(node.getNode(0));
  }

  public void visitPredecrementExpression(GNode node) {
    dispatch(node.getNode(0));
  }  
  
  public void visitPreincrementExpression(GNode node) {
  	dispatch(node.getNode(0));
  } 
  
  public void visitPointerDeclarator(GNode node) {
    dispatch(node.getNode(1));
  }

  public void visitRelationalExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(2));
  }

  public void visitReturnStatement(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitSwitchStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    dispatch(test);

    for(Object o : body) {
      if(o != null) {
      	if(!(o instanceof GNode)) {
      		if(o instanceof LineMarker) {
      			o = ((LineMarker) o).getNode();
      		} else {
      			throw new IllegalArgumentException("What on earth is " + o + "?");
      		}
      	}
      	Node node_o = (Node) o;
      	dispatch(node_o);
      }
    }
  }

  public void visitSubscriptExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(1));
  }
  
  public void visitShiftExpression(GNode node) {
    dispatch(node.getNode(0));
    dispatch(node.getNode(2));
  }

  public void visitUnaryMinusExpression(GNode node) {
    dispatch(node.getNode(0));
  }

  public void visitWhileStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    dispatch(test);
    
    Node invariant = body.getNode(0).getNode(0);
    if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION) 
        && invariant != null
        && invariant.hasName("FunctionCall") 
        && invariant.getNode(0).getString(0).equals("INVARIANT")) {      
      body = body.getNode(1);
      dispatch(body);
      dispatch(invariant);
    } else {
      dispatch(body);
    }
  }
  
  public void visitForStatement(GNode node) {    
    enterScope(node);
    compoStmtAsScope = false;
    Node init = node.getNode(0);
    Node test = node.getNode(1);
    Node incr = node.getNode(2);
    Node body = node.getNode(3);
    dispatch(test);
    dispatch(init);
    dispatch(body);
    dispatch(incr);
    exitScope();
  }
  
  public void visitBreakStatement(GNode node) {
  	//TODO: something
  }

  public void visitCaseLabel(GNode node) {
  	//TODO: something
  }
  
  public void visitCharacterConstant(GNode node) {
    //TODO: something
  }
  
  public void visitContinueStatement(GNode node) {
  	//TODO: something
  }
  
  public void visitDefaultLabel(GNode node) {
  	//TODO: something
  }

  /* Do-nothing implementation to make errors from header files go away. */
  public void visitFunctionDeclarator(GNode node) {
    //TODO: something
  }
  
  public void visitSpecifierQualifierList(GNode node) {
    //TODO: something
  }  

  public void visitPrimaryIdentifier(GNode node) {
  	//TODO: something
  }

  public void visitSimpleDeclarator(GNode node) {
  	//TODO: something
  }
  
  public void visitStringConstant(GNode node) {
  	//TODO: something
  }
  
  public void visitIntegerConstant(GNode node) {
  	//TODO: something
  }
  
  public void visitFloatingConstant(GNode node) {
  	//TODO: something
  }
}
