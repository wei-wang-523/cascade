package edu.nyu.cascade.c;

import static edu.nyu.cascade.util.IOUtils.debug;
import static edu.nyu.cascade.util.IOUtils.debugC;
import static edu.nyu.cascade.util.IOUtils.debugEnabled;

import java.util.Collections;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import xtc.tree.*;
import xtc.type.*;
import xtc.type.Type.Tag;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import edu.nyu.cascade.ir.IRBooleanExpression;
import edu.nyu.cascade.ir.IRControlFlowGraph;
import edu.nyu.cascade.ir.IRLocations;
import edu.nyu.cascade.ir.IRVarInfo;
import edu.nyu.cascade.ir.SymbolTable;
import edu.nyu.cascade.ir.impl.BasicBlock;
import edu.nyu.cascade.ir.impl.CaseGuard;
import edu.nyu.cascade.ir.impl.ControlFlowGraph;
import edu.nyu.cascade.ir.impl.DefaultCaseGuard;
import edu.nyu.cascade.ir.impl.Guard;
import edu.nyu.cascade.ir.impl.Statement;
import edu.nyu.cascade.ir.impl.VarInfoFactory;
import edu.nyu.cascade.util.IOUtils;
import edu.nyu.cascade.util.Identifiers;
import edu.nyu.cascade.util.Pair;
import edu.nyu.cascade.util.Preferences;
import edu.nyu.cascade.util.ReservedFunction;

/**
 * A CFG builder for ASTs generated by <code>edu.nyu.cascade.c.CParser</code>. A
 * typical client should just call <code>getCfgs</code> to extract CFGs from the
 * AST for a compilation unit.
 * 
 * <em>Note for implementers:</em> To add support for a parse rule Foo, add a
 * method <code>T visitFoo(Node n)</code>, where <code>T</code> is a type of
 * your choosing (or <code>void</code>). See the documentation for
 * <code>xtc.tree.Visitor</code> for more information.
 */
public class CfgBuilder extends Visitor {
	
  /**
   * Retrieve the CFGs from the given parse tree, using the given symbol table
   * and expression manager.
   * 
   * @param symbolTable
   *          The symbol table to use for symbols defined and used in the parse
   *          tree.
   * @param ast
   *          A <code>edu.nyu.cascade.c.CParser</code> compilation unit AST
   *          node.
   * @return A <code>Map</code> from declaration nodes to CFGs.
   */
  @SuppressWarnings("unchecked")
  public static Map<Node, IRControlFlowGraph> getCfgs(SymbolTable symbolTable, CAnalyzer cAnalyzer,
      Node ast) {
    return (Map<Node, IRControlFlowGraph>) new CfgBuilder(symbolTable, cAnalyzer).dispatch(ast);
  }

  /**
   * A Scope is either a loop or a switch statement. We distinguish the two by
   * setting caseExpr to non-null. If non-null, it represents the argument E of
   * a switch statement "switch(E) { ... }".
   */
  private static class Scope {
    private final BasicBlock entry, exit;
    private final CExpression caseExpr;
    private final List<CaseGuard> caseGuards;
    private boolean hasDefault;
    private final List<Statement> caseExprSideEffectStmts;
    private final Map<GNode, BasicBlock> labelStmtMap;

    public Scope(BasicBlock entry, BasicBlock exit) {
      this(entry, exit, null);
    }

    public Scope(BasicBlock entry, BasicBlock exit, CExpression caseExpr) {
    	this(entry, exit, null, Collections.<Statement>emptyList());
    }
    
    public Scope(BasicBlock entry, BasicBlock exit, CExpression caseExpr, List<Statement> sideEffectStmts) {
      this.entry = entry;
      this.exit = exit;
      this.caseExpr = caseExpr;
      this.caseGuards = Lists.newArrayList();
      this.caseExprSideEffectStmts = ImmutableList.copyOf(sideEffectStmts);
      this.hasDefault = false;
      this.labelStmtMap = Maps.newHashMap();
    }
    
    public void registerLabelStmt(GNode labelNode, BasicBlock labelStmt) {
    	labelStmtMap.put(labelNode, labelStmt);
    }
    
    public BasicBlock getLabelStmt(GNode labelNode) {
    	Preconditions.checkArgument(labelStmtMap.containsKey(labelNode));
    	return labelStmtMap.get(labelNode);
    }
    
    public List<Statement> getSideEffectStatements() {
    	return caseExprSideEffectStmts;
    }

    public CExpression getCaseExpr() {
      return caseExpr;
    }

    public BasicBlock getEntry() {
      return entry;
    }

    public BasicBlock getExit() {
      return exit;
    }

    public void addCaseGuard(CaseGuard g) {
      caseGuards.add(g);
    }

    public List<CaseGuard> getCaseGuards() {
      return caseGuards;
    }

    public boolean hasDefault() {
      return hasDefault;
    }

    public void setHasDefault() {
      hasDefault = true;
    }
  }
  
  private BasicBlock currentBlock;
  private List<Statement> postStatements, appendStatements;
  private Deque<Integer> alignments;  // for pretty-printing

	/**
   * Greater than 0 if the visitor is currently inside an expression, as opposed
   * to a statement. Allows us to distinguish between "statement expressions"
   * that embedded in larger expressions, so we can properly order effects.
   * E.g., while processing if( (n = cp++) == 0 ), expressionDepth will be 1
   * when the visitor reaches the assignment operator, so that we know the
   * assignment expression is a side effect of the expression, and not a
   * first-class statement.
   * 
   * Should be incremented by every expression visited and decremented when the
   * visitor returns.
   */
  private int expressionDepth;
  private ControlFlowGraph currentCfg;

	private final SymbolTable symbolTable;
	private final Map<Node, ControlFlowGraph> cfgs;
  private final Deque<Scope> scopes;
  private final CAnalyzer cAnalyzer;
  private final Map<Pair<String, ControlFlowGraph>, BasicBlock> labeledBlocks;
  
  private CfgBuilder(SymbolTable symbolTable, CAnalyzer cAnalyzer) {
    this.symbolTable = symbolTable;
    this.cAnalyzer = cAnalyzer;
    alignments = Lists.newLinkedList();
    cfgs = Maps.newHashMap();
    scopes = Lists.newLinkedList();
    labeledBlocks = Maps.newHashMap();
  }

  /** Align the debug output with the last seen tab stop. */
  private void peekAlign() {
    if( debugEnabled() ) {
      debug().align(alignments.peek());
    }
  }

  /** Align the debug output with the last tab stop and discard it. */
  private void popAlign() {
    if( debugEnabled() ) {
      debug().align(alignments.remove());
    }
  }

  /** Push a tab stop. */
  private void pushAlign() {
    if( debugEnabled() ) {
      alignments.push(debug().column());
    }
  }

  /**
   * Add a statement. If the statement is part of an expression (e.g.,
   * "(n = *cp) == 0"), we queue it as a post-statement. If the expression depth
   * is 0 (meaning, this is a top-level statement, we flush the post-statement
   * queue.
   */
  private void addStatement(Statement stmt) {  	
    postStatements.add(stmt);
    if (expressionDepth == 0) {
      flushPostStatements();
    }
  }
  
  /** Append the append-statements accumulated to the post-statements. */
  private void flushAppendStatements() {
  	if(appendStatements.isEmpty()) return;
    postStatements.addAll(appendStatements);
    appendStatements.clear();
  }

	/** Append the post-statements accumulated to the current block. */
  private void flushPostStatements() {
  	flushAppendStatements();
    addAndFlushPostStatements(currentBlock);
  }
  
  private void buildEdgeWithGuardSideEffect(BasicBlock src, 
  		Guard ifBranch, BasicBlock ifBlock, 
  		Guard elseBranch, BasicBlock elseBlock) {
  	if(appendStatements.isEmpty()) {
  		currentCfg.addEdge(src, ifBranch, ifBlock);
  		currentCfg.addEdge(src, elseBranch, elseBlock);
  	} else {
  		BasicBlock sideEffectIfBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  		BasicBlock sideEffectElseBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  		sideEffectIfBlock.addStatements(appendStatements);
  		sideEffectElseBlock.addStatements(appendStatements);
  		currentCfg.addEdge(src, ifBranch, sideEffectIfBlock);
  		currentCfg.addEdge(src, elseBranch, sideEffectElseBlock);
  		currentCfg.addEdge(sideEffectIfBlock, ifBlock);
  		currentCfg.addEdge(sideEffectElseBlock, elseBlock);
  		appendStatements.clear();
  	}
  }
  
  private void buildCaseEdgeWithGuardSideEffect(BasicBlock src, IRBooleanExpression guard, BasicBlock labelStmt) {
  	List<Statement> sideEffectStmts = getCaseExprSideEffectStmts();
  	if(sideEffectStmts.isEmpty()) {
  		currentCfg.addEdge(src, guard, labelStmt);
  	} else {
  		BasicBlock sideEffectBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  		sideEffectBlock.addStatements(sideEffectStmts);
  		currentCfg.addEdge(src, guard, sideEffectBlock);
  		currentCfg.addEdge(sideEffectBlock, labelStmt);
  	}
  	
  }

  /** Append the post-statements accumulated to all given blocks. This is necessary
   * to make sure effects appear along all branches. E.g., the side effects of an 
   * "if" test will appear at the beginning of both the "then" and "else" blocks. */
  private void addAndFlushPostStatements(BasicBlock first, BasicBlock... rest) {    
    if (postStatements.isEmpty())
      return;

    debug().pln(
        "flushing expression statement effects (size=" + postStatements.size()
            + ") to block #" + first.getId()).flush();
    first.addStatements(postStatements);
    for (BasicBlock b : rest) {
      debug().pln(
          "flushing expression statement effects (size="
              + postStatements.size() + ") to block #" + b.getId()).flush();
      b.addStatements(postStatements);
    }
    postStatements.clear();
  }

  /** Dump all scopes. Useful as a hygienic measure against ill-nested scopes. */
  private void flushScopes() {
    scopes.clear();
  }

  /** Leave a scope. */
  private void popScope() {
    //exitScope();
    scopes.removeFirst();
  }

  /** Enter a scope bracketed by the given blocks. */
  private void pushScope(BasicBlock entry, BasicBlock exit) {
    Scope s = new Scope(entry, exit);
    scopes.addFirst(s);
  }

  /** Enter a case scope bracketed by the given blocks, guarded by the given expression. */
  private void pushSwitchScope(BasicBlock entry, BasicBlock exit, CExpression caseExpr) {
    Scope s = new Scope(entry, exit, caseExpr, appendStatements);
    scopes.addFirst(s);
    appendStatements.clear();
  }
  
  /** SymbolTable enters a nested scope. */
  private void enterScope(GNode node) {
    symbolTable.enterScope(node);
  }
  
  /** SymbolTable exit a nested scope. */
  private void exitScope() {
    symbolTable.setScope(symbolTable.getCurrentScope().getParent());
  }
  
  /** Get the side-effect statements for case expression. Used to flush them into
   * every label statement
   */
  private List<Statement> getCaseExprSideEffectStmts() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getSideEffectStatements();
      }
    }
    return null;
  }

  /** Find the smallest enclosing non-case scope. Used to resolve continue
   * statements. */
  private BasicBlock getLoopEntry() {
    // TODO: will this work for more complex CFGs?
    for (Scope s : scopes) {
      if (s.getCaseExpr() == null) {
        return s.getEntry();
      }
    }
    return null;
  }

  /** Find the smallest enclosing case scope. Used to find the in-edge for 
   * case labels. */
  private BasicBlock getSwitchEntry() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getEntry();
      }
    }
    return null;
  }

  /** Find the exit block for the smallest enclosing scope. */
  private BasicBlock getBreakTarget() {
    return scopes.peek().getExit();
  }

  /** Add an outgoing edge to the given exit block iff the current block has
   * no existing successors. Used when the builder "falls through" the end of 
   * a block which may or may not have acquired an unconditional edge somewhere
   * deeper in the AST. E.g., if the last statement of a loop is a break, then
   * there shouldn't be a default edge back to the loop test.
   */
  private void closeCurrentBlock(BasicBlock exitBlock) {
    if (currentCfg.getSuccessors(currentBlock).isEmpty()) {
      currentCfg.addEdge(currentBlock, exitBlock);
    }
  }

  private void addCaseGuard(CaseGuard g) {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        s.addCaseGuard(g);
      }
    }
  }

  private List<CaseGuard> getCaseGuards() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getCaseGuards();
      }
    }
    return ImmutableList.of();
  }

  private CExpression getCaseExpression() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getCaseExpr();
      }
    }
    return null;
  }

  private boolean hasDefault() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.hasDefault();
      }
    }
    return true;
  }

  private void setHasDefault() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        s.setHasDefault();
        return;
      }
    }
  }
  
  private void setCaseGuard(CaseGuard guard) {
    for(Scope s : scopes) {
      if(s.getCaseExpr() != null) {
        s.addCaseGuard(guard);
      }
    }
  }
  
  private void registerLabelStmt(GNode labelNode, BasicBlock labelStmt) {
    for(Scope s : scopes) {
      if(s.getCaseExpr() != null) {
        s.registerLabelStmt(labelNode, labelStmt);
      }
    }
  }
  
  private BasicBlock getLabelStmt(GNode labelNode) {
    for(Scope s : scopes) {
      if(s.getCaseExpr() != null) {
        return s.getLabelStmt(labelNode);
      }
    }
    return null;
  }

  private CExpression recurseOnExpression(Node node) {
    expressionDepth++;
    CExpression e = (CExpression) dispatch(node);
    expressionDepth--;
    return e;
  }
  
  private Node defineReturnVarNode(String funcName, Node func) {
    String varName = Identifiers.uniquify(Identifiers.RETURN_VAR_PREFIX + '_' + funcName);
    Location loc = func.getLocation();
    Type type = CType.getType(func);
    type = type.annotate().shape(new DynamicReference(varName,type));
    
    Node varDeclareNode = GNode.create("SimpleDeclarator", varName);
    varDeclareNode.setLocation(loc);
    type.mark(varDeclareNode);
    cAnalyzer.processExpression(varDeclareNode);
    
    createAuxVarBinding(varDeclareNode, Identifiers.RETURN_VAR_PREFIX);
    
    Node varNode = GNode.create("PrimaryIdentifier", varName);
    varNode.setLocation(loc);
    type.mark(varNode);
    //FIXME: process(varNode) sometimes attach root scope
    cAnalyzer.processExpression(varNode);
    
    return varNode; 
  }
  
  private Type redefineStringType(Type type) {
		Preconditions.checkArgument(type.hasShape());
		Preconditions.checkArgument(type.getShape().isString());
		Preconditions.checkArgument(type.resolve().isArray());
		ArrayT arrayType = type.resolve().toArray().copy();
		arrayType.setLength(arrayType.getLength() + 1);
		
		Reference shape = type.getShape();
		String literal =  ((StringReference) shape).getLiteral();
		StringBuilder sb = new StringBuilder();
		if(literal != null) sb.append(literal);
		sb.append('\u0000');
		
		Reference newShape = new StringReference(sb.toString(), arrayType);
		return arrayType.annotate().shape(newShape);
	}

	private Node defineStringVarNode(GNode stringConst) {
		String varName = Identifiers.uniquify(Identifiers.STRING_VAR_PREFIX);
		
	  Node stringVar = GNode.create("SimpleDeclarator", varName);
	  stringVar.setLocation(stringConst.getLocation());
	  Type type = CType.getType(stringConst);
	  type = redefineStringType(type);
		type.mark(stringVar);
		cAnalyzer.processExpression(stringVar);
	  
	  createAuxVarBinding(stringVar, Identifiers.STRING_VAR_PREFIX);
	  
	  Node varNode = GNode.create("PrimaryIdentifier", varName);
	  varNode.setLocation(stringVar.getLocation());
		for(String label : stringVar.properties()) { // copy properties
			varNode.setProperty(label, stringVar.getProperty(label));
		}
	  return varNode; 
	}
	
	private CExpression[] getCharacterExprs(Node sourceNode) {
	  Reference shape = CType.getType(sourceNode).getShape();
	  assert(shape.isString());
	  String literal = ((StringReference) shape).getLiteral();		
		CExpression[] charExprs = new CExpression[literal.length() + 1];
		
		String endChar = new StringBuilder().append('\'').append('\u0000').append('\'').toString();
		GNode endCharNode = GNode.create("CharacterConstant", endChar);
		endCharNode.setLocation(sourceNode.getLocation());
		cAnalyzer.processExpression(endCharNode);
		CExpression endCharExpr = expressionOf(endCharNode);
		charExprs[literal.length()] = endCharExpr;
		
		for(int i = 0; i < literal.length(); i++) {
			char c = literal.charAt(i);
			String charLiteral = new StringBuilder().append('\'').append(c).append('\'').toString();
			GNode node = GNode.create("CharacterConstant", charLiteral);
			node.setLocation(sourceNode.getLocation());
			cAnalyzer.processExpression(node);
			CExpression charExpr = expressionOf(node);
			charExprs[i] = charExpr;
		}
		
		return charExprs;
	}
  
  private void createAuxVarBinding(Node node, String label) {
  	String name = node.getString(0);
  	debug().pln(
  			"Looking up binding for variable: " + name + " in symbol table "
  					+ symbolTable);
  	
  	assert(!symbolTable.isDefined(name));
  	Type type = CType.getType(node);
  	IRVarInfo binding = VarInfoFactory.createVarInfoWithType(
  			CType.getScopeName(node), name, type);
  	if(CType.isScalar(type.resolve())) {
  		binding.setProperty(Identifiers.HOARE_VAR, true);
  	} else {
  		binding.setProperty(Identifiers.HOARE_VAR, false);
  	}
  	
  	binding.setDeclarationNode(node);
  	binding.setProperty(Identifiers.AUXLABEL, label);
  	symbolTable.define(name, binding);
  	debug().pln("Binding: " + binding).flush();
  	
  	CExpression resExpr = expressionOf(node);
  	Statement declareStmt = Statement.declare(node, resExpr);
  	addStatement(declareStmt);
  }
  
  private void updateCurrentBlock(BasicBlock block) {
    /* Add the statements to the current block */
    flushPostStatements();
    currentBlock = block;
  }

	@Override
  public Object unableToVisit(Node node) {
    IOUtils
        .debug()
        .p("Ignoring unexpected node type: ")
        .pln(node.getName())
        .flush();
    return node;
  }

  public CExpression visitAdditiveExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(2, rhsExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitMultiplicativeExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(2, rhsExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitAddressExpression(GNode node) 
  		throws CfgBuilderException {
  	CExpression opExpr = recurseOnExpression(node.getNode(0));
  	
    if(opExpr.getSourceNode().hasName("PrimaryIdentifier")) {
    	String name = opExpr.getSourceNode().getString(0);
    	IRVarInfo info = symbolTable.lookup(name);
    	if(info.getXtcType().resolve().isFunction())
    		throw new CfgBuilderException("Take address of a function " + opExpr);
    	info.setProperty(Identifiers.HOARE_VAR, false);
    }
    
  	node.set(0, opExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitAssignmentExpression(GNode node) {
    Node lhsNode = node.getNode(0);
    String assignOperator = node.getString(1);
    Node rhsNode = node.getNode(2);
    
    if( debugEnabled() ) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(lhsNode).p(
        " " + assignOperator + " ");
      
      IOUtils.debugC(rhsNode).pln().flush();
    }
    
    CExpression lhsExpr = recurseOnExpression(lhsNode);
    CExpression rhsExpr = recurseOnExpression(rhsNode);
    
    /* The assignment operator may be one of +=, -=, et al., in which case the
     * rhs is the whole statement, e.g., x += y becomes something like (assign x
     * (x += y)) instead of (assign x (x+y)), because replacing the operator
     * here would be a PITA. It's up to the expression visitor to turn that into
     * an addition.
     */
    if (!"=".equals(assignOperator)) rhsExpr = expressionOf(node);
    addStatement(Statement.assign(node, lhsExpr, rhsExpr));
    
    return lhsExpr;
  }

	public CExpression visitBitwiseAndExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(1, rhsExpr.getSourceNode());
    return expressionOf(node);
  }
	
	public CExpression visitBitwiseNegationExpression(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    node.set(0, srcExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitBitwiseOrExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(1, rhsExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitBitwiseXorExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(1, rhsExpr.getSourceNode());
    return expressionOf(node);
  }

  public void visitBreakStatement(GNode node) {
    debug().loc(node).p(' ').indent().pln("break").flush();
    /* Add a skip as an anchor for the source line. */
    addStatement(Statement.skip(node));
    currentCfg.addEdge(currentBlock, getBreakTarget());

    /* This block will be a repository for dead code! 
     * TODO: Detect and eliminate vestigial blocks?
     */
    BasicBlock newBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    updateCurrentBlock(newBlock);
  }

  public void visitCaseLabel(GNode node) {
    Node val = node.getNode(0);

    debug()
        .loc(node)
        .p(' ')
        .decr()
        .indent()
        .p("case ");
    debugC(val)
        .pln(":")
        .incr()
        .flush();

    CExpression valExpr = recurseOnExpression(val);
    CaseGuard guard = new CaseGuard(getCaseExpression(), valExpr);
    this.buildCaseEdgeWithGuardSideEffect(getSwitchEntry(), guard, currentBlock);
//    currentCfg.addEdge(getSwitchEntry(), guard, currentBlock);
    addCaseGuard(guard);
  }

  public CExpression visitCastExpression(GNode node) {    
    CExpression typeExpr = recurseOnExpression(node.getNode(0));
    CExpression opExpr = recurseOnExpression(node.getNode(1));
    
    node.set(0, typeExpr.getSourceNode());
    node.set(1, opExpr.getSourceNode());
    
    return expressionOf(node);
  }

  public CExpression visitCharacterConstant(GNode node) {
    return expressionOf(node);
  }
  
  public CExpression visitConditionalExpression(GNode node) {
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), 
    		symbolTable.getCurrentScope());
    BasicBlock ifBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock elseBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    
    updateCurrentBlock(entryBlock);
    
    CExpression condExpr = recurseOnExpression(node.getNode(0));
    
    Guard ifBranch = Guard.create(condExpr);
    Guard elseBranch = ifBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, ifBlock, elseBranch, elseBlock);
//    currentCfg.addEdge(currentBlock, ifBranch, ifBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, elseBlock);
    
    updateCurrentBlock(ifBlock);
    CExpression trueExpr = recurseOnExpression(node.getNode(1));
    closeCurrentBlock(exitBlock);

    updateCurrentBlock(elseBlock);
    CExpression falseExpr = recurseOnExpression(node.getNode(2));
    closeCurrentBlock(exitBlock);
    updateCurrentBlock(exitBlock);
    
  	node.set(0, condExpr.getSourceNode());
  	node.set(1, trueExpr.getSourceNode());
  	node.set(2, falseExpr.getSourceNode());
    return expressionOf(node);
  }

  public void visitCommaExpression(GNode node) {
    for(Object o : node) {
      dispatch((Node) o);
    }
  }
  
  public void visitCompoundStatement(GNode node) {
  	if(symbolTable.hasScope(node)) {
    	enterScope(node);
      for (Object o : node) {
        dispatch((Node) o);
      }
      exitScope();
    } else {
      for (Object o : node) {
        dispatch((Node) o);
      }
    }
  }

  public void visitContinueStatement(GNode node) {
    debug().loc(node).indent().pln("continue").flush();
    /* Add a skip as an anchor for the source line. */
    addStatement(Statement.skip(node));
    currentCfg.addEdge(currentBlock, getLoopEntry());

    /*
     * This block will be a repository for dead code! 
     * TODO: Detect and eliminate vestigial blocks?
     */
    BasicBlock newBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    updateCurrentBlock(newBlock);
  }

  public void visitDeclaration(GNode node) {
    Node type = node.getNode(1);
    
    Node declarations = node.getNode(2);
    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(type).p(' ');
      IOUtils.debugC(declarations).pln().flush();
    }
    
    if(type != null) {
    	for(Object o : type) {
    		dispatch((Node) o); flushPostStatements();
    	}
    }
    
    if (declarations != null) {
    	for (Object o : declarations) {
    		dispatch((Node) o); flushPostStatements();
      }
    }
  }
  
  public CExpression visitEnumerator(GNode node) {
  	String name = node.getString(0);
    debug().pln(
        "Looking up binding for variable: " + name + " in symbol table "
            + symbolTable);
    assert (symbolTable.isDefined(name));
    assert (symbolTable.getCurrentScope().equals(symbolTable.lookupScope(name)));
    
    IRVarInfo varInfo = symbolTable.lookup(name);
    varInfo.setDeclarationNode(node);
    
    return expressionOf(node);
  }

  public void visitDefaultLabel(GNode node) {
    IOUtils
        .debug()
        .loc(node)
        .p(' ')
        .decr()
        .indent()
        .pln("default:")
        .incr()
        .flush();

    IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
    buildCaseEdgeWithGuardSideEffect(getSwitchEntry(), guard, currentBlock);
//    currentCfg.addEdge(getSwitchEntry(), guard, currentBlock);
    setHasDefault();
  }

  public CExpression visitEqualityExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(2, rhsExpr.getSourceNode());
    return expressionOf(node);
  }

  public List<CExpression> visitExpressionList(GNode node) {
    List<CExpression> subExprList = Lists.newArrayListWithCapacity(node.size());
    for (Object elem : node) {
      CExpression subExpr = recurseOnExpression((Node) elem);
      subExprList.add(subExpr);
    }
    return subExprList;
  }

  public void visitExpressionStatement(GNode node) {
    dispatch(node.getNode(0));
    flushPostStatements();
  }

  /* Do-nothing implementation to make errors from header files go away. */
  public CExpression visitFunctionDeclarator(GNode node) {
    // TODO: Something
    return recurseOnExpression(node.getNode(0));
  }
  
  public CExpression visitAttributedDeclarator(GNode node) {
  	return recurseOnExpression(node.getNode(1));
  }
  
  public CExpression visitArrayDeclarator(GNode node) {
    Node declareNode = node.getNode(0);
    return recurseOnExpression(declareNode);
  }
  
  @SuppressWarnings("unchecked")
  public CExpression visitFunctionCall(GNode node) throws CfgBuilderException {
  	Node funNode = node.getNode(0);
  	
  	if(!GNode.cast(funNode).hasName("PrimaryIdentifier"))
  		throw new CfgBuilderException("Invalid function call " + expressionOf(funNode));
  		
    Node argList = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent().p(funNode).p('(');
      if(argList != null) {
        Iterator<Object> argIter = argList.iterator();
        while (argIter.hasNext()) {
          Node arg = (Node) argIter.next();
          debug().p(arg);
          if (argIter.hasNext()) {
            debug().p(',');
          }
        }
      }
      debug().pln(')').flush();
    }
    
    assert(funNode.hasName("PrimaryIdentifier"));
    String funcName = funNode.getString(0);
    List<CExpression> argExprs = (List<CExpression>) dispatch(argList);
   
    /* For non-reserved functions, add functionCall statement, we'll do the
     * real calling as pick the cfg of the function in the RunProcessor
     */
  	
    if(ReservedFunction.FUN_FORALL.equals(funcName)
    		|| ReservedFunction.FUN_EXISTS.equals(funcName)
    		|| ReservedFunction.FUN_IMPLIES.equals(funcName)
    		|| ReservedFunction.FUN_VALID_ACCESS.equals(funcName)
    		|| ReservedFunction.FUN_VALID_MALLOC.equals(funcName)
    		|| ReservedFunction.FUN_VALID_FREE.equals(funcName)) {
    	return expressionOf(node);
    }
  	
		if(ReservedFunction.MALLOC.equals(funcName)) {
			Node returnNode = defineReturnVarNode(funcName, node);
			CExpression returnExpr = recurseOnExpression(returnNode);
			addStatement(Statement.malloc(node, returnExpr, argExprs.get(0)));
			return returnExpr;
		}
		
		if(ReservedFunction.CALLOC.equals(funcName)) {
			Node returnNode = defineReturnVarNode(funcName, node);
			CExpression returnExpr = recurseOnExpression(returnNode);
			addStatement(Statement.calloc(node, returnExpr, argExprs.get(0), argExprs.get(1)));
			return returnExpr;
		}
		
		if(ReservedFunction.ALLOCA.equals(funcName) || ReservedFunction.BUILTIN_ALLOCA.equals(funcName)) {
			Node returnNode = defineReturnVarNode(funcName, node);
			CExpression returnExpr = recurseOnExpression(returnNode);
			addStatement(Statement.alloca(node, returnExpr, argExprs.get(0)));
			return returnExpr;
		}
    
		if(ReservedFunction.FREE.equals(funcName)) {
      addStatement(Statement.free(node, argExprs.get(0)));
      return expressionOf(node);
    }
		
		if(ReservedFunction.EXIT.equals(funcName)) {
    	addStatement(Statement.returnStmt(node, argExprs.get(0)));
    	currentCfg.addEdge(currentBlock, currentCfg.getExit());
    	return expressionOf(node);
    }
		
		if(ReservedFunction.VERIFIER_ASSUME.equals(funcName)) {
			addStatement(Statement.assumeStmt(node, argExprs.get(0)));
			return expressionOf(node);
    } 
		
		if(ReservedFunction.ANNO_ASSERT.equals(funcName)) {
			if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
				addStatement(Statement.assertStmt(node, argExprs.get(0)));
			} else {
				CExpression funExpr = expressionOf(funNode);
	  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			}
			return expressionOf(node);
    } 

		if(ReservedFunction.ANNO_ASSUME.equals(funcName)) {
			if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
				addStatement(Statement.assumeStmt(node, argExprs.get(0)));
			} else {
				CExpression funExpr = expressionOf(funNode);
	  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			}
			return expressionOf(node);
    } 

		if(ReservedFunction.ANNO_INVARIANT.equals(funcName)) {
			if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
				addStatement(Statement.assumeStmt(node, argExprs.get(0)));
				addStatement(Statement.assertStmt(node, argExprs.get(0)));
			} else {
				CExpression funExpr = expressionOf(funNode);
	  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			}
			return expressionOf(node);
    }
		
		if(ReservedFunction.MEMSET.equals(funcName) 
				|| ReservedFunction.MEMCOPY.equals(funcName)) {
			CExpression funExpr = expressionOf(funNode);
  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			return argExprs.get(0);
		}

  	if(!cAnalyzer.processExpression(funNode).resolve().isFunction())
  		throw new CfgBuilderException("Invalid function call " + expressionOf(funNode));
		
  	/*
    // [chris 1/8/2010] FIXME: avoid a lookup on the function name, since it
    // will probably return null
    if( funNode.hasName("PrimaryIdentifier") ) {
      funExpr = CExpression.create(funNode,symbolTable.getCurrentScope());
    } else {
      funExpr = recurseOnExpression(funNode);
    }*/
		
    if(CType.getType(node).tag().equals(Tag.VOID)) { // void return type of function
      CExpression funExpr = expressionOf(funNode);
      Statement stmt = Statement.functionCall(node, funExpr, argExprs);
      stmt.setProperty(Identifiers.STMTFUNC, true);
      if(argExprs != null) stmt.setProperty(Identifiers.ARGUMENTS, argExprs);
      stmt.setProperty(Identifiers.FUNCNAME, funcName);
      addStatement(stmt);
      return expressionOf(node);
    }
    
  	Node returnNode = defineReturnVarNode(funcName, node);
    Node assignNode = GNode.create("AssignmentExpression", returnNode, "=", node);
    cAnalyzer.processExpression(assignNode);
    assignNode.setLocation(node.getLocation());
    
    CExpression returnExpr = recurseOnExpression(returnNode);
    CExpression funCallExpr = expressionOf(node);
    Statement stmt = Statement.assign(assignNode, returnExpr, funCallExpr);
    stmt.setProperty(Identifiers.STMTFUNCASSIGN, true);
    if(argExprs != null) stmt.setProperty(Identifiers.ARGUMENTS, argExprs);
    stmt.setProperty(Identifiers.FUNCNAME, funcName);
  	addStatement(stmt);
  	return returnExpr;  	
  }

  public void visitDoStatement(GNode node) {
    Node test = node.getNode(1);
    Node body = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" do(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }
    
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), 
        symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    
    pushScope(entryBlock, exitBlock);
    updateCurrentBlock(entryBlock);
    
    currentCfg.addEdge(currentBlock, bodyBlock);
    
    updateCurrentBlock(bodyBlock);
    dispatch(body);
    
    CExpression testExpr = recurseOnExpression(test);

    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, entryBlock, elseBranch, exitBlock);
//    currentCfg.addEdge(currentBlock, ifBranch, entryBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, exitBlock);
    
    closeCurrentBlock(entryBlock);  // close the loop
    
    updateCurrentBlock(exitBlock);  // exit the loop
    popScope();

    if( debugEnabled() ) {
      popAlign();
      debug().decr().flush();
    }
  }
  
  public void visitFunctionDefinition(GNode node) {
    /* Node is: FunctionDefinition(type modifiers, type signature (including
     * id), locals, body)
  	 */
  	
  	/* Push global info */
  	BasicBlock preCurrentBlock = currentBlock;
  	List<Statement> prePostStatements = postStatements;
  	List<Statement> preAppendStatements = appendStatements;
  	int preExpressionDepth = expressionDepth;
  	ControlFlowGraph preCfg = currentCfg;
  	
  	/* Analyze current function definition */
    final GNode returnType = node.getGeneric(1);
    final GNode declarator = node.getGeneric(2);
    final GNode identifier = CAnalyzer.getDeclaredId(declarator);
    final String functionName = identifier.getString(0);
    
    /* FunctionDefiniion node has 'scope' property, here enter the scope
     * directly, ignore the following compoundStatement; it means no need
     * to enter scope there, set 'CompoStmtAsScope' as 'false'
     */
    enterScope(node);
    
    currentCfg = new ControlFlowGraph(node, functionName, symbolTable
        .getCurrentScope());
    updateCurrentBlock(currentCfg.getEntry());
    addStatement(Statement.scopeEnt(node));
    
    BasicBlock block = currentCfg.newBlock(symbolTable.getCurrentScope());
    currentCfg.addEdge(currentBlock, block);
    updateCurrentBlock(block);
    
    flushScopes();
    pushScope(currentCfg.getEntry(), currentCfg.getExit());
    

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      IOUtils.debugC(returnType).p(' ');
      IOUtils.debugC(declarator).pln(" {").incr().flush();
    }

    postStatements = Lists.newLinkedList();
    appendStatements = Lists.newArrayList();
    expressionDepth = 0;

    GNode parameters = CAnalyzer.getFunctionDeclarator(declarator).getGeneric(1);
    cAnalyzer.processExpression(parameters);
    if( parameters != null ) {
      parameters = parameters.getGeneric(0);
    }
    
    if (parameters != null) {
      for (Object o : parameters) {
        assert (o instanceof Node);
        assert (((Node) o).hasName("ParameterDeclaration"));
        // Drill down to the actual declaration
        dispatch(((Node) o).getNode(1));
      }
    }

    /* recurse on the function body */
    final GNode body = node.getGeneric(4);
    dispatch(body);
    
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
    updateCurrentBlock(currentCfg.getExit());
    
    addStatement(Statement.scopeExit(symbolTable.getCurrentScope().getName()));
    
    cfgs.put(node, currentCfg);

    if( debugEnabled() ) {
      popAlign();
      debug().decr().pln("} // end function").flush().reset();
      currentCfg.format(debug());
    }
    
    flushPostStatements();
    exitScope();
    
    /* Pop global info */
    currentCfg = preCfg;
    currentBlock = preCurrentBlock;
    postStatements = prePostStatements;
    appendStatements = preAppendStatements;
    expressionDepth = preExpressionDepth;
  }

  public void visitGotoStatement(GNode node) {
    Node labelNode = node.getNode(1);
    Preconditions.checkArgument(labelNode.hasName("PrimaryIdentifier"));
    recurseOnExpression(labelNode);
    String labelName = labelNode.getString(0);
    Pair<String, ControlFlowGraph> key = Pair.of(labelName, currentCfg);
    if(!labeledBlocks.containsKey(key)) {
    	BasicBlock labelStmt = currentCfg.newLabelBlock(
    			symbolTable.getCurrentScope());
    	labelStmt.addPreLabel(labelName);
      labeledBlocks.put(key, labelStmt);
    }
    BasicBlock labelBlock = labeledBlocks.get(key);
    currentCfg.addEdge(currentBlock, labelBlock);
    BasicBlock newBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    updateCurrentBlock(newBlock);
  }
  
  public void visitIfElseStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);
    Node elsePart = node.getNode(2);

    if( debugEnabled() ) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().indent().p("if(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }

    xtc.util.SymbolTable.Scope currScope = symbolTable.getCurrentScope();
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), currScope);
    BasicBlock ifBlock = currentCfg.newBlock(currScope);
    BasicBlock elseBlock = currentCfg.newBlock(currScope);
    BasicBlock exitBlock = currentCfg.newBlock(currScope);

    currentCfg.addEdge(currentBlock, entryBlock);
    updateCurrentBlock(entryBlock);
    
    CExpression testExpr = recurseOnExpression(test);
    
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, ifBlock, elseBranch, elseBlock);
    
//    currentCfg.addEdge(currentBlock, ifBranch, ifBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, elseBlock);
    
    updateCurrentBlock(ifBlock);
    dispatch(ifPart);
    closeCurrentBlock(exitBlock);

    if( debugEnabled() ) {
      peekAlign();
      debug().p(' ').decr().indent().pln("else").incr().flush();
    }
    
    updateCurrentBlock(elseBlock);
    dispatch(elsePart);
    closeCurrentBlock(exitBlock);
    updateCurrentBlock(exitBlock);

    if( debugEnabled() ) {
    popAlign();
    debug().decr().pln("}").flush();
    }
  }
  
  public void visitEmptyStatement(GNode node) {
  	return;
  }

  public void visitIfStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent().p("if(");
      debugC(test).pln(")").incr().flush();
    }
    
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock ifBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    updateCurrentBlock(entryBlock);
    
    CExpression testExpr = recurseOnExpression(test);
    
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, ifBlock, elseBranch, exitBlock);
//    currentCfg.addEdge(currentBlock, ifBranch, ifBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, exitBlock);

    updateCurrentBlock(ifBlock);
    dispatch(ifPart);
    closeCurrentBlock(exitBlock);
    updateCurrentBlock(exitBlock);

    debug().decr().flush();
  }

  CExpression expressionOf(Node node) {
  	return symbolTable.hasScope(node) ? 
  			CExpression.create(node, symbolTable.getScope(node)) :
  				CExpression.create(node, symbolTable.getCurrentScope());
  }

  public CExpression visitIndirectionExpression(GNode node) {
    CExpression opExpr = recurseOnExpression(node.getNode(0));
    node.set(0, opExpr.getSourceNode());
    return expressionOf(node);
  }

  public void visitInitializedDeclarator(GNode node) {
    Node varNode = node.getNode(1);
    Object val = node.get(4);
    
    Type varType = cAnalyzer.processExpression(varNode);
    if(varType.resolve().isFunction()) return;
    
    boolean isStatic = varType.hasShape() && varType.getShape().isStatic();
  	CExpression varExpr = recurseOnExpression(varNode);
    
    if(val == null) {
    	if(isStatic) {
    		Statement initStmt = Statement.initialize(node, varExpr);
        initStmt.addPreLabel(Identifiers.STATIC);
    		addStatement(initStmt);
    	}
    	return;
    }
    
    // Explicitly add the expression depth, since dispatch might return
    // a collection of CExpressions
    expressionDepth++;
    Object o = dispatch((Node) val);
    expressionDepth--;
    
    if(o instanceof CExpression) {
    	CExpression valExpr = (CExpression) o;      
    	Statement initStmt = Statement.initialize(node, varExpr, valExpr);
    	if(isStatic) initStmt.addPreLabel(Identifiers.STATIC);
    	addStatement(initStmt);
    } else {
    	@SuppressWarnings("unchecked")
    	List<CExpression> valExprs = (List<CExpression>) o;    	
    	Statement initStmt = Statement.initialize(node, varExpr, 
    			valExprs.toArray(new CExpression[valExprs.size()]));
    	if(isStatic) initStmt.addPreLabel(Identifiers.STATIC);
    	addStatement(initStmt);
    }
  }

  public List<CExpression> visitInitializerList(GNode node) {
    List<CExpression> subExprList = Lists.newArrayList();
    for (Object elem : node) {
    	List<CExpression> subExprs = visitInitializerListEntry(GNode.cast(elem));
      subExprList.addAll(subExprs);
    }
    return subExprList;
  }

  @SuppressWarnings("unchecked")
	public List<CExpression> visitInitializerListEntry(GNode node) {
    Object o = dispatch(node.getNode(1));
    if(o instanceof CExpression) 
    	return Collections.singletonList((CExpression) o);
    else 
    	return (List<CExpression>) o;
  }
  
  public CExpression visitIntegerConstant(GNode node) {
    return expressionOf(node);
  }
  
  public CExpression visitFloatingConstant(GNode node) {
    return expressionOf(node);
  }

  public void visitLabeledStatement(GNode node) {
    Node label = node.getNode(0);
    Node stmt = node.getNode(1);
    
    BasicBlock labelStmt;
    
    if(label.hasName("NamedLabel")) {
      String labelName = label.getString(0);
      Pair<String, ControlFlowGraph> key = Pair.of(labelName, currentCfg);
      if(labeledBlocks.containsKey(key)) {
      	labelStmt = labeledBlocks.get(key);
      	labelStmt.addLocation(IRLocations.ofLocation(node.getLocation()));
      } else {
      	labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
        		symbolTable.getCurrentScope());
      	labelStmt.addPreLabel(labelName);
        labeledBlocks.put(key, labelStmt);
      }
      currentCfg.addEdge(currentBlock, labelStmt);
    } else if(label.hasName("CaseLabel")) {
      CExpression testExpr = getCaseExpression();
      CExpression caseLabel = recurseOnExpression(label.getNode(0));
      CaseGuard caseBranch = new CaseGuard(testExpr, caseLabel);
      setCaseGuard(caseBranch);
      labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
      		symbolTable.getCurrentScope());
      buildCaseEdgeWithGuardSideEffect(currentBlock, caseBranch, labelStmt);
      
      // register label stmt for close previous unclosed case
      registerLabelStmt(node, labelStmt);
    } else if(label.hasName("DefaultLabel")) {
      setHasDefault();
      IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
      labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
      		symbolTable.getCurrentScope());
      buildCaseEdgeWithGuardSideEffect(currentBlock, guard, labelStmt);
      
      // register label stmt for close previous unclosed case
      registerLabelStmt(node, labelStmt);
    } else {
    	labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
      		symbolTable.getCurrentScope());
    }
    
    updateCurrentBlock(labelStmt);
    dispatch(stmt);
  }

  public CExpression visitLogicalAndExpression(GNode node) {
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock elseBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    
    updateCurrentBlock(entryBlock);
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    
    Guard elseBranch = Guard.create(lhsExpr);
    Guard ifBranch = elseBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, exitBlock, elseBranch, elseBlock);
//    currentCfg.addEdge(currentBlock, ifBranch, exitBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, elseBlock);

    updateCurrentBlock(elseBlock);
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    closeCurrentBlock(exitBlock);
    updateCurrentBlock(exitBlock);
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(1, rhsExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitLogicalOrExpression(GNode node) {
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock elseBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    
    updateCurrentBlock(entryBlock);
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    
    Guard ifBranch = Guard.create(lhsExpr);
    Guard elseBranch = ifBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, exitBlock, elseBranch, elseBlock);
//    currentCfg.addEdge(currentBlock, ifBranch, exitBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, elseBlock);

    updateCurrentBlock(elseBlock);
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));    
    closeCurrentBlock(exitBlock);
    updateCurrentBlock(exitBlock);
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(1, rhsExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitLogicalNegationExpression(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    node.set(0, srcExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitSizeofExpression(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    node.set(0, srcExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitTypeName(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    node.set(0, srcExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitSpecifierQualifierList(GNode node) {
    return expressionOf(node);
  }

  public CExpression visitDirectComponentSelection(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    node.set(0, srcExpr.getSourceNode());
    return expressionOf(node);
  }

  public CExpression visitIndirectComponentSelection(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    node.set(0, srcExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitPostdecrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" - 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    Node oneNode = GNode.create("IntegerConstant", "1");    
    Node decNode = GNode.create("AdditiveExpression", opNode, "-", oneNode);
    Node assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", decNode);
    oneNode.setLocation(loc);
    decNode.setLocation(loc);
    assignNode.setLocation(loc);
    
    cAnalyzer.processExpression(assignNode);
    Statement stmt = Statement.assign(assignNode, opExpr, CExpression.create(decNode, opExpr.getScope()));
    if(expressionDepth == 0)       addStatement(stmt);
    else                           appendStatements.add(stmt);

    return opExpr; // return the *prior value* of the operand
  }
  
  public CExpression visitPostincrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" + 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    Node oneNode = GNode.create("IntegerConstant", "1");    
    Node incNode = GNode.create("AdditiveExpression", opNode, "+", oneNode);
    Node assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", incNode);
    oneNode.setLocation(loc);
    incNode.setLocation(loc);
    assignNode.setLocation(loc);
    
    cAnalyzer.processExpression(assignNode);
    Statement stmt = Statement.assign(assignNode, opExpr, CExpression.
        create(incNode, opExpr.getScope()));
    if(expressionDepth == 0)       addStatement(stmt);
    else                           appendStatements.add(stmt);

    return opExpr; // return the *prior value* of the operand
  }

  public CExpression visitPredecrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" - 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    Node oneNode = GNode.create("IntegerConstant", "1");    
    Node decNode = GNode.create("AdditiveExpression", opNode, "-", oneNode);
    Node assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", decNode);
    oneNode.setLocation(loc);
    decNode.setLocation(loc);
    assignNode.setLocation(loc);
    
    cAnalyzer.processExpression(assignNode);  
    addStatement(Statement.assign(assignNode, opExpr, CExpression
        .create(decNode, opExpr.getScope())));

    return opExpr; // return the *prior value* of the operand
  }  
  
  public CExpression visitPreincrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" + 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    Node oneNode = GNode.create("IntegerConstant", "1");
    Node incNode = GNode.create("AdditiveExpression", opNode, "+", oneNode);
    Node assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", incNode);
    oneNode.setLocation(loc);
    incNode.setLocation(loc);
    assignNode.setLocation(loc);
    
    cAnalyzer.processExpression(assignNode);
    addStatement(Statement.assign(node, opExpr, CExpression
        .create(incNode, opExpr.getScope())));

    return opExpr; // return the *prior value* of the operand
  } 
  
  public CExpression visitPointerDeclarator(GNode node) {
  	return recurseOnExpression(node.getNode(1));
  }

  public CExpression visitPrimaryIdentifier(GNode node) {
    return expressionOf(node);
  }

  public CExpression visitSimpleDeclarator(GNode node) {
    String name = node.getString(0);
    debug().pln(
        "Looking up binding for variable: " + name + " in symbol table "
            + symbolTable);
    assert (symbolTable.isDefined(name));
    assert(CType.hasScope(node));
    
    /* attach type and scope properties to node */
    
    IRVarInfo varInfo = symbolTable.lookup(name);
    varInfo.setDeclarationNode(node);
    
    Type type = varInfo.getXtcType();
    
    /* Ignore typedef symbol */
    if(type.isAlias() && type.toAlias().getName().equals(name))
    	return expressionOf(node);
    
    /* Ignore function symbol */
    if(type.resolve().isFunction())		return expressionOf(node);
    
    // FIXME: array, struct and union type variables are also Hoare variable ?
    if(CType.isScalar(type.resolve())) {
    	varInfo.setProperty(Identifiers.HOARE_VAR, true);
    } else {
    	varInfo.setProperty(Identifiers.HOARE_VAR, false);
    }
    
    CExpression resExpr = expressionOf(node);
    Statement declareStmt = Statement.declare(node, resExpr);
    
    if(type.getShape().isStatic())
    	declareStmt.addPreLabel(Identifiers.STATIC);
    
    addStatement(declareStmt);
    
    Node primaryId = GNode.create("PrimaryIdentifier", name);
    primaryId.setLocation(node.getLocation());
    for(String label : node.properties()) {
    	primaryId.setProperty(label, node.getProperty(label));
    }
    return expressionOf(primaryId);
  }

  public CExpression visitRelationalExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    node.set(0, lhsExpr.getSourceNode());
    node.set(2, rhsExpr.getSourceNode());
    return expressionOf(node);
  }

  public void visitReturnStatement(GNode node) {
    if( debugEnabled() ) {
      IOUtils
        .debug()
        .loc(node)
        .p(' ')
        .indent()
        .p("return ");
      IOUtils.debugC(node.getNode(0))
        .pln()
        .flush();
    }
    
    if(node.getNode(0) != null) {
      CExpression val = recurseOnExpression(node.getNode(0));

      /*
       * NOTE: there may be reachable statements after a return statement in the
       * CFG. For example, "return i++" will be dismantled to "return i; i++".
       */
      addStatement(Statement.returnStmt(node, val));
    } else {
    	addStatement(Statement.returnStmt(node));
    }
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
    BasicBlock newBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    updateCurrentBlock(newBlock);
  }
  
	public CExpression visitStringConstant(GNode node) {
  	CExpression[] characters = getCharacterExprs(node);
  	Node stringVarNode = defineStringVarNode(node);
  	CExpression stringVar = recurseOnExpression(stringVarNode);
  	Statement stmt = Statement.initialize(node, stringVar, characters);
  	addStatement(stmt);
  	return stringVar;
  }

  public void visitSwitchStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    debug().loc(node).p(' ');
    pushAlign();
    debug()
        .indent()
        .p("switch(");
    debugC(test)
        .pln(")")
        .incr()
        .incr()
        .flush();

    // TODO: handle side effects in test expression
    // Create side-effect block and duplicate for every case?

    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), 
            symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    CExpression testExpr = recurseOnExpression(test);
    
    pushSwitchScope(entryBlock, exitBlock, testExpr);
    
    updateCurrentBlock(entryBlock);
    
    BasicBlock preUnclosedCaseBlock = null;
    
    for(Object o : body) {
      if(o == null) continue;
      if(!(o instanceof Node)) {
      	assert(o instanceof LineMarker);
      	o = ((LineMarker) o).getNode();
      }
      Node node_o = (Node) o;
      if(node_o.hasName("LabeledStatement")) {
      	updateCurrentBlock(entryBlock);
      	dispatch(node_o);
      	if(preUnclosedCaseBlock != null) {
      		BasicBlock labelStmt = getLabelStmt(GNode.cast(node_o));
      		currentCfg.addEdge(preUnclosedCaseBlock, labelStmt);
      	}
      	
      	if(hasDefault())  // FIXME: how about add break in default case
      		closeCurrentBlock(exitBlock);
      	else
      		preUnclosedCaseBlock = currentBlock;
      } else if(node_o.hasName("BreakStatement")) {
      	dispatch(node_o);
      	closeCurrentBlock(exitBlock);
      	preUnclosedCaseBlock = null;
      } else {
      	dispatch(node_o);
      	preUnclosedCaseBlock = currentBlock;
      }
    }

    updateCurrentBlock(exitBlock);

    if (!hasDefault()) {
      IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
      buildCaseEdgeWithGuardSideEffect(entryBlock, guard, exitBlock);
    }

    popScope();
    popAlign();
    debug().decr().flush();
  }

  public CExpression visitSubscriptExpression(GNode node) {
    CExpression baseExpr = recurseOnExpression(node.getNode(0));
    CExpression idxExpr = recurseOnExpression(node.getNode(1));
    
    node.set(0, baseExpr.getSourceNode());
    node.set(1, idxExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitShiftExpression(GNode node) {
    return expressionOf(node);
  }

  /** Visit the specified translation unit. */
  public Map<Node, ? super ControlFlowGraph> visitTranslationUnit(GNode n) {
    cfgs.clear();
    
    /* build global cfg for global statements */
    currentCfg = new ControlFlowGraph(n, Identifiers.GLOBAL_CFG, symbolTable
        .rootScope());
    
    if (debugEnabled()) {
      debug().loc(n).p(' ');
      pushAlign();
      debug().p(" Global CFG (");
      IOUtils.debug().pln(")").incr().flush();
    }
    
    postStatements = Lists.newLinkedList();
    appendStatements = Lists.newArrayList();
    expressionDepth = 0;
    
    BasicBlock newBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    currentCfg.addEdge(currentCfg.getEntry(), newBlock);
    updateCurrentBlock(newBlock);
    
    for (Object o : n) {
      dispatch((Node) o);
    }
    
    flushPostStatements();
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
    
    cfgs.put(n, currentCfg);
    
    return cfgs;
  }

  public CExpression visitUnaryPlusExpression(GNode node) {
    CExpression opExpr = recurseOnExpression(node.getNode(0));
    node.set(0, opExpr.getSourceNode());
    return expressionOf(node);
  }
  
  public CExpression visitUnaryMinusExpression(GNode node) {
    CExpression opExpr = recurseOnExpression(node.getNode(0));
    node.set(0, opExpr.getSourceNode());
    return expressionOf(node);
  }

  public void visitWhileStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" while(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }
    
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock bodyBlock = symbolTable.hasScope(body) ?
    		currentCfg.newBlock(symbolTable.getScope(body)) : currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());

    pushScope(entryBlock, exitBlock);
    currentCfg.addEdge(currentBlock, entryBlock);
    updateCurrentBlock(entryBlock);
    
    CExpression testExpr = recurseOnExpression(test);
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    buildEdgeWithGuardSideEffect(currentBlock, ifBranch, bodyBlock, elseBranch, exitBlock);
//    currentCfg.addEdge(currentBlock, ifBranch, bodyBlock);
//    currentCfg.addEdge(currentBlock, elseBranch, exitBlock);
    
    updateCurrentBlock(bodyBlock);
    dispatch(body);
    
    closeCurrentBlock(entryBlock); // close the loop
    updateCurrentBlock(exitBlock);
    popScope();
    
    if( debugEnabled() ) {
      popAlign();
      debug().decr().flush();
    }
  }
  
  public void visitForStatement(GNode node) {
    Node init = node.getNode(0);
    Node test = node.getNode(1);
    Node incr = node.getNode(2);
    Node body = node.getNode(3);
    
    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" for(");
      IOUtils.debugC(init).p("; ");
      IOUtils.debugC(test).p("; ");
      IOUtils.debugC(incr).pln(")").incr().flush();
    }
    
    /* ForStatement node has 'scope' property, here enter the scope directly,
     * ignore the following compoundStatement; it means no need to enter scope
     * there, set 'CompoStmtAsScope' as 'false'
     */
    enterScope(node);
    
    BasicBlock initBlock = currentCfg.newLoopInitBlock(symbolTable.getCurrentScope());
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), 
        symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock incrBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock loopExitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    pushScope(initBlock, loopExitBlock);
  	
    currentCfg.addEdge(currentBlock, initBlock);
  	
    updateCurrentBlock(initBlock);   
    dispatch(init);
    
    currentCfg.addEdge(currentBlock, entryBlock);
    
    updateCurrentBlock(entryBlock);
    
    if(test != null) {
    	CExpression testExpr = recurseOnExpression(test);
    	
    	Guard ifBranch = Guard.create(testExpr);
    	Guard elseBranch = ifBranch.negate();
    
    	buildEdgeWithGuardSideEffect(currentBlock, ifBranch, bodyBlock, elseBranch, loopExitBlock);
//    	currentCfg.addEdge(currentBlock, ifBranch, bodyBlock);
//    	currentCfg.addEdge(currentBlock, elseBranch, loopExitBlock);
    } else {
    	currentCfg.addEdge(currentBlock, bodyBlock);
    }
    
    updateCurrentBlock(bodyBlock);
    dispatch(body);
    currentCfg.addEdge(currentBlock, incrBlock);
    updateCurrentBlock(incrBlock);
    dispatch(incr);    

    currentCfg.addEdge(currentBlock, entryBlock);
    currentCfg.addEdge(loopExitBlock, exitBlock);
    
    closeCurrentBlock(entryBlock); // close the loop
    updateCurrentBlock(exitBlock);
    popScope();

    if( debugEnabled() ) {
        popAlign();
        debug().decr().flush();
    }   
    exitScope();
  }
}