package edu.nyu.cascade.c;

import static edu.nyu.cascade.util.IOUtils.debug;
import static edu.nyu.cascade.util.IOUtils.debugC;
import static edu.nyu.cascade.util.IOUtils.debugEnabled;

import java.io.File;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import xtc.tree.GNode;
import xtc.tree.Location;
import xtc.tree.Node;
import xtc.tree.Visitor;
import xtc.type.IntegerT;
import xtc.type.NumberT;
import xtc.type.Type;
import xtc.util.Pair;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import edu.nyu.cascade.control.Run;
import edu.nyu.cascade.ir.IRBooleanExpression;
import edu.nyu.cascade.ir.IRControlFlowGraph;
import edu.nyu.cascade.ir.IRStatement;
import edu.nyu.cascade.ir.IRVarInfo;
import edu.nyu.cascade.ir.SymbolTable;
import edu.nyu.cascade.ir.IRStatement.StatementType;
import edu.nyu.cascade.ir.expr.ExpressionFactoryException;
import edu.nyu.cascade.ir.impl.BasicBlock;
import edu.nyu.cascade.ir.impl.CaseGuard;
import edu.nyu.cascade.ir.impl.ControlFlowGraph;
import edu.nyu.cascade.ir.impl.DefaultCaseGuard;
import edu.nyu.cascade.ir.impl.Guard;
import edu.nyu.cascade.ir.impl.IRExpressionImpl;
import edu.nyu.cascade.ir.impl.Statement;
import edu.nyu.cascade.ir.impl.VarInfo;
import edu.nyu.cascade.ir.type.IRIntegerType;
import edu.nyu.cascade.util.IOUtils;
import edu.nyu.cascade.util.Preferences;

/**
 * A CFG builder for ASTs generated by <code>edu.nyu.cascade.c.CParser</code>. A
 * typical client should just call <code>getCfgs</code> to extract CFGs from the
 * AST for a compilation unit.
 * 
 * <em>Note for implementers:</em> To add support for a parse rule Foo, add a
 * method <code>T visitFoo(Node n)</code>, where <code>T</code> is a type of
 * your choosing (or <code>void</code>). See the documentation for
 * <code>xtc.tree.Visitor</code> for more information.
 */
public class CfgBuilder extends Visitor {
  
  /**
   * Retrieve the CFGs from the given parse tree, using the given symbol table
   * and expression manager.
   * 
   * @param symbolTable
   *          The symbol table to use for symbols defined and used in the parse
   *          tree.
   * @param ast
   *          A <code>edu.nyu.cascade.c.CParser</code> compilation unit AST
   *          node.
   * @return A <code>Map</code> from declaration nodes to CFGs.
   */
  @SuppressWarnings("unchecked")
  public static Map<Node, IRControlFlowGraph> getCfgs(SymbolTable symbolTable,
      Node ast) {
    return (Map<Node, IRControlFlowGraph>) new CfgBuilder(symbolTable).dispatch(ast);
  }
  
  /**
   * Store the global statements for each file. Each declared function node in 
   * a file has its CFG. Various functions may share global statements as 
   * #define. This structure is to store the global statements.
   */
  private static Map<File, List<IRStatement>> globalStmts;
  
  /**
   * Pick the global statements of one file.
   * @param run
   * @return a list of statements, empty if none.
   */
  public static List<IRStatement> getGlobalStmts(Run run) {
    File file = run.getStartPosition().getFile();
    return globalStmts.get(file);
  }

  /**
   * A Scope is either a loop or a switch statement. We distinguish the two by
   * setting caseExpr to non-null. If non-null, it represents the argument E of
   * a switch statement "switch(E) { ... }".
   */
  private static class Scope {
    private final BasicBlock entry, exit;
    private final CExpression caseExpr;
    private final List<CaseGuard> caseGuards;
    private boolean hasDefault;

    public Scope(BasicBlock entry, BasicBlock exit) {
      this(entry, exit, null);
    }

    public Scope(BasicBlock entry, BasicBlock exit, CExpression caseExpr) {
      this.entry = entry;
      this.exit = exit;
      this.caseExpr = caseExpr;
      this.caseGuards = Lists.newArrayList();
      this.hasDefault = false;
    }

    public CExpression getCaseExpr() {
      return caseExpr;
    }

    public BasicBlock getEntry() {
      return entry;
    }

    public BasicBlock getExit() {
      return exit;
    }

    public void addCaseGuard(CaseGuard g) {
      caseGuards.add(g);
    }

    public List<CaseGuard> getCaseGuards() {
      return caseGuards;
    }

    public boolean hasDefault() {
      return hasDefault;
    }

    public void setHasDefault() {
      hasDefault = true;
    }
  }

  private final SymbolTable symbolTable;
  private BasicBlock currentBlock;
  private List<Statement> postStatements, appendStatements;
  private Deque<Integer> alignments;  // for pretty-printing

  /**
   * Greater than 0 if the visitor is currently inside an expression, as opposed
   * to a statement. Allows us to distinguish between "statement expressions"
   * that embedded in larger expressions, so we can properly order effects.
   * E.g., while processing if( (n = cp++) == 0 ), expressionDepth will be 1
   * when the visitor reaches the assignment operator, so that we know the
   * assignment expression is a side effect of the expression, and not a
   * first-class statement.
   * 
   * Should be incremented by every expression visited and decremented when the
   * visitor returns.
   */
  private int expressionDepth;
  private int TEST_VAR_POSTFIX;
  private int STRING_VAR_POSTFIX;
  private int MALLOC_VAR_POSTFIX;
  private Map<Node, ControlFlowGraph> cfgs;
  private ControlFlowGraph currentCfg;
  private Deque<Scope> scopes;
  private Map<String, BasicBlock> labeledBlocks;
  private List<xtc.util.SymbolTable.Scope> nestedScopes;
  /**
   * Store the alias name of struct type or union type
   */
  private Map<Type, String> typeAliasMap;   
  /**
   * Whether to treat compoundStatement '{...}' as a new scope in the symbolTable;
   * it's thanks to the functionDefinition and forStatement -- these two kinds of
   * nodes have the 'scope' property, and we call enterScope(node) for these nodes.
   * E.g. for(int i=0; i<10; i++) {...}, if to call enterScope() in the compound 
   * statement inside the loop body {...}, the initializedDeclarator 'int i=0' will
   * cause error, since the symbolTable under current scope doesn't include it.
   */
  private boolean compoStmtAsScope;

  private CfgBuilder(SymbolTable symbolTable) {
    this.symbolTable = symbolTable;
    alignments = Lists.newLinkedList();
    cfgs = Maps.newHashMap();
    scopes = Lists.newLinkedList();
    nestedScopes = Lists.newArrayList();
    compoStmtAsScope = true;
    labeledBlocks = Maps.newHashMap();
    globalStmts = Maps.newHashMap();
    typeAliasMap = Maps.newHashMap();
    TEST_VAR_POSTFIX = 0;
    MALLOC_VAR_POSTFIX = 0;
    STRING_VAR_POSTFIX = 0;
  }

  /** Align the debug output with the last seen tab stop. */
  private void peekAlign() {
    if( debugEnabled() ) {
      debug().align(alignments.peek());
    }
  }

  /** Align the debug output with the last tab stop and discard it. */
  private void popAlign() {
    if( debugEnabled() ) {
      debug().align(alignments.remove());
    }
  }

  /** Push a tab stop. */
  private void pushAlign() {
    if( debugEnabled() ) {
      alignments.push(debug().column());
    }
  }

  /**
   * Add a statement. If the statement is part of an expression (e.g.,
   * "(n = *cp) == 0"), we queue it as a post-statement. If the expression depth
   * is 0 (meaning, this is a top-level statement, we flush the post-statement
   * queue.
   */
  private void addStatement(Statement stmt) {
    postStatements.add(stmt);
    postStatements.addAll(appendStatements);
    appendStatements.clear();
    if (expressionDepth == 0) {
      flushPostStatements();
    }
  }

  /** Append the post-statements accumulated to the current block. */
  private void flushPostStatements() {
    addAndFlushPostStatements(currentBlock);
  }

  /** Append the post-statements accumulated to all given blocks. This is necessary
   * to make sure effects appear along all branches. E.g., the side effects of an 
   * "if" test will appear at the beginning of both the "then" and "else" blocks. */
  private void addAndFlushPostStatements(BasicBlock first, BasicBlock... rest) {
    // TODO: What about prestatements (like ++i)?
    if (postStatements.isEmpty())
      return;

    debug().pln(
        "flushing expression statement effects (size=" + postStatements.size()
            + ") to block #" + first.getId()).flush();
    first.addStatements(postStatements);
    for (BasicBlock b : rest) {
      debug().pln(
          "flushing expression statement effects (size="
              + postStatements.size() + ") to block #" + b.getId()).flush();
      b.addStatements(postStatements);
    }
    postStatements.clear();
  }

  /** Dump all scopes. Useful as a hygienic measure against ill-nested scopes. */
  private void flushScopes() {
    scopes.clear();
  }

  /** Leave a scope. */
  private void popScope() {
    //exitScope();
    scopes.removeFirst();
  }

  /** Enter a scope bracketed by the given blocks. */
  private void pushScope(BasicBlock entry, BasicBlock exit) {
    Scope s = new Scope(entry, exit);
    scopes.addFirst(s);
  }

  /** Enter a case scope bracketed by the given blocks, guarded by the given expression. */
  private void pushScope(BasicBlock entry, BasicBlock exit, CExpression caseExpr) {
    Scope s = new Scope(entry, exit, caseExpr);
    scopes.addFirst(s);
  }
  
  private int getKeyFromScope(xtc.util.SymbolTable.Scope scope) {
    String name = scope.getName();
    int startIndex = name.indexOf('(');
    int endIndex = name.indexOf(')');
    String keyName = name.substring(startIndex+1, endIndex);
    return Integer.valueOf(keyName);
  }
  
  private boolean lessOrEqualScopes(xtc.util.SymbolTable.Scope lScope,
      xtc.util.SymbolTable.Scope rScope) {
    int lKey = getKeyFromScope(lScope);
    int rKey = getKeyFromScope(rScope);
    return (lKey <= rKey);
  }
  
  private List<xtc.util.SymbolTable.Scope> 
  mergeSortScopes(List<xtc.util.SymbolTable.Scope> scopes) {
    if(scopes.size() <=1)
      return scopes;
    
    List<xtc.util.SymbolTable.Scope> lScopes, rScopes, resScopes;
    lScopes = scopes.subList(0, scopes.size()/2);
    rScopes = scopes.subList(scopes.size()/2, scopes.size());
    resScopes = Lists.newArrayList();
    lScopes = mergeSortScopes(lScopes);
    rScopes = mergeSortScopes(rScopes);
    while(!(lScopes.isEmpty() && rScopes.isEmpty())) {
      xtc.util.SymbolTable.Scope lScope, rScope;
      if(!(lScopes.isEmpty() || rScopes.isEmpty())) {
        lScope = lScopes.get(0);
        rScope = rScopes.get(0);
        if(lessOrEqualScopes(lScope, rScope)) {
          resScopes.add(lScope);
          lScopes = lScopes.subList(1, lScopes.size());
        } else {
          resScopes.add(rScope);
          rScopes = rScopes.subList(1, rScopes.size());
        }
      } else if(!lScopes.isEmpty()) {
        lScope = lScopes.get(0);
        resScopes.add(lScope);
        lScopes = lScopes.subList(1, lScopes.size()); 
      } else if(!rScopes.isEmpty()) {
        rScope = rScopes.get(0);
        resScopes.add(rScope);
        rScopes = rScopes.subList(1, rScopes.size());       
      }
    }
    return resScopes;
  }
  
  /** Initialize nested scopes. For example: 
   * block(0){block(1)}, block(2){block(3), block(4)}, block(5). 
   * The initialization of nestedScopes works as follows:
   * {block(0), block(2), block(5)}
   * Get block(0)'s nested scopes {block(1)};
   * Get block(2)'s nested scopes {block(3), block(4)};
   * Insert {block(1)} after block(0), insert {block(3), block(4) after block(2)
   * The final nestedScopes is
   * {block(0), block(1), block(2), block(3), block(4), block(5)} */
  private List<xtc.util.SymbolTable.Scope> 
  initializeNestedScopes(xtc.util.SymbolTable.Scope scope) {
    List<xtc.util.SymbolTable.Scope> nestedScopes, resScopes;
    nestedScopes = Lists.newArrayList();
    resScopes = Lists.newArrayList();
    
    // Pick the nested scopes under 'scope'
    Iterator<String> scopeIter = scope.nested();
    while(scopeIter.hasNext())
      nestedScopes.add(scope.getNested(scopeIter.next()));
    // Sort the nested scopes
    nestedScopes = mergeSortScopes(nestedScopes);
    /*
     *  Recursively initialize the nested scopes under element in nestedScopes.
     *  Add the element and its nested scopes into resScopes.
     */ 
    for(xtc.util.SymbolTable.Scope nestedScope : nestedScopes) {
      resScopes.add(nestedScope);
      resScopes.addAll(initializeNestedScopes(nestedScope));
    }
    return resScopes;
  }
  
  /** Initialize the nestedScopes only if it's empty. */
  private void initializeNestedScopes() {
    if(nestedScopes.isEmpty())
      nestedScopes = initializeNestedScopes(symbolTable.getCurrentScope());
  }
  
  /** SymbolTable enters a nested scope. */
  private void enterScope() {
    // For node without property 'scope' attached.
    symbolTable.setScope(nestedScopes.remove(0));
  }
  
  /** SymbolTable enters a nested scope. */
  private void enterScope(GNode node) {
    // For node is FunctionDefinition node or ForStatement node with 'scope' property
    symbolTable.enterScope(node);
    initializeNestedScopes();
    /* Remove the scope in nested scopes is only valid for forLoop, not for FunctionDefinition
     * Because, Function's scope is root scope, not recorded in nestedScopes
     */
    if(!(nestedScopes.isEmpty() || node.getName().equals("FunctionDefinition")))
      nestedScopes.remove(0);
  }
  
  /** SymbolTable exit a nested scope. */
  private void exitScope() {
    symbolTable.setScope(symbolTable.getCurrentScope().getParent());
  }
  
  /** Choose the way to add statement, globally or locally. */
  private void addStatementGlobalOrLocal(Statement stmt) {
    if(this.currentCfg != null) 
      addStatement(stmt);
    else {
      File file = stmt.getLocation().getFile();
      if(!globalStmts.containsKey(file)) {
        globalStmts.put(file, Lists.newArrayList((IRStatement) stmt));
      } else {
        globalStmts.get(file).add(stmt);
      }
    }
  }

  /** Find the smallest enclosing non-case scope. Used to resolve continue
   * statements. */
  private BasicBlock getLoopEntry() {
    // TODO: will this work for more complex CFGs?
    for (Scope s : scopes) {
      if (s.getCaseExpr() == null) {
        return s.getEntry();
      }
    }
    return null;
  }

  /** Find the smallest enclosing case scope. Used to find the in-edge for 
   * case labels. */
  private BasicBlock getSwitchEntry() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getEntry();
      }
    }
    return null;
  }

  /** Find the exit block for the smallest enclosing scope. */
  private BasicBlock getBreakTarget() {
    return scopes.peek().getExit();
  }

  /** Add an outgoing edge to the given exit block iff the current block has
   * no existing successors. Used when the builder "falls through" the end of 
   * a block which may or may not have acquired an unconditional edge somewhere
   * deeper in the AST. E.g., if the last statement of a loop is a break, then
   * there shouldn't be a default edge back to the loop test.
   */
  private void closeCurrentBlock(BasicBlock exitBlock) {
    if (currentCfg.getSuccessors(currentBlock).isEmpty()) {
      currentCfg.addEdge(currentBlock, exitBlock);
    }
  }

  private void addCaseGuard(CaseGuard g) {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        s.addCaseGuard(g);
      }
    }
  }

  private List<CaseGuard> getCaseGuards() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getCaseGuards();
      }
    }
    return ImmutableList.of();
  }

  private CExpression getCaseExpression() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getCaseExpr();
      }
    }
    return null;
  }

  private boolean hasDefault() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.hasDefault();
      }
    }
    return true;
  }

  private void setHasDefault() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        s.setHasDefault();
        return;
      }
    }
  }
  
  private void setCaseGuard(CaseGuard guard) {
    for(Scope s : scopes) {
      if(s.getCaseExpr() != null) {
        s.addCaseGuard(guard);
      }
    }
  }

  private CExpression recurseOnExpression(Node node) {
    expressionDepth++;
    CExpression e = (CExpression) dispatch(node);
    expressionDepth--;
    return e;
  }

  private Node defineTestVarNode(Node test) {
    String varName = "TEST_VAR_" + (TEST_VAR_POSTFIX++);
    GNode varNode = GNode.create("PrimaryIdentifier", varName);
    xtc.util.SymbolTable.Scope scope = symbolTable.getCurrentScope();
    varNode.setLocation(test.getLocation());
    // FIXME: such property really helpful?
    varNode.setProperty(xtc.Constants.SCOPE, scope);
    varNode.setProperty(xtc.Constants.TYPE, (NumberT.INT));
    IRVarInfo varInfo = new VarInfo(scope, varName, IRIntegerType.getInstance(), varNode);
    symbolTable.define(varName, varInfo);
    return varNode; 
  }
  
  private Node defineMallocVarNode(Node malloc) {
    String varName = "MALLOC_VAR_" + (MALLOC_VAR_POSTFIX++);
    GNode varNode = GNode.create("PrimaryIdentifier", varName);
    xtc.util.SymbolTable.Scope scope = symbolTable.getCurrentScope();
    varNode.setLocation(malloc.getLocation());
    // FIXME: such property really helpful?
    varNode.setProperty(xtc.Constants.SCOPE, scope);
    varNode.setProperty(xtc.Constants.TYPE, malloc.getProperty(xtc.Constants.TYPE));
    IRVarInfo varInfo = new VarInfo(scope, varName, IRIntegerType.getInstance(), varNode);
    symbolTable.define(varName, varInfo);
    return varNode; 
  }

  private Node defineStringVarNode(Node string) {
    String varName = "STRING_VAR_" + (STRING_VAR_POSTFIX++);
    GNode varNode = GNode.create("PrimaryIdentifier", varName);
    xtc.util.SymbolTable.Scope scope = symbolTable.getCurrentScope();
    varNode.setLocation(string.getLocation());
    // FIXME: such property really helpful?
    varNode.setProperty(xtc.Constants.SCOPE, scope);
    varNode.setProperty(xtc.Constants.TYPE, (new xtc.type.ArrayT(NumberT.CHAR, 3)));
    IRVarInfo varInfo = new VarInfo(scope, varName, IRIntegerType.getInstance(), varNode);
    symbolTable.define(varName, varInfo);
    return varNode; 
  }
  
  private Node defineStringConstNode(Node node, String string) {
    GNode stringNode = GNode.create("StringConstant", string);
    xtc.util.SymbolTable.Scope scope = symbolTable.getCurrentScope();
    stringNode.setLocation(node.getLocation());
    stringNode.setProperty(xtc.Constants.SCOPE, scope);
    return stringNode; 
  }
  
  private Type unwrapped(Type type) {
    while(type.isAlias() || type.isAnnotated() || type.isVariable()) {
      type = type.resolve();
      type = type.deannotate();
    }
    return type;
  }
  
  private Type lookupType(Node node) throws ExpressionFactoryException {
    Type type = (Type) node.getProperty(xtc.Constants.TYPE);
    if (type == null)
      throw new ExpressionFactoryException("Type not found: " + node);
    return type;
  }
  
  private boolean isAliasName(Node node) throws ExpressionFactoryException {
    if(!"SimpleDeclarator".equals(node.getName()))  return false;
    
    String name = node.getString(0);
    Type type = symbolTable.lookupType(name);
    if(!type.isAlias())     return false;
    
    String aliasName = type.toAlias().getName();
    typeAliasMap.put(unwrapped(type), aliasName);
    return aliasName.equals(name);
  }
  
  private GNode getSizeofTypeNode(Type type, Node node) {
    Type resType = unwrapped(type);
    
    if(resType.isArray()) { // Pick the base type of array
      while(resType.isArray()) {
        resType = unwrapped(resType.toArray().getType());
      }
    }
    
    GNode node1 = null; 
    if(resType.isStruct()) {
      String typeName = typeAliasMap.containsKey(resType) ? 
          typeAliasMap.get(resType) : resType.getName();
      node1 = GNode.create("StructureTypeReference", null, typeName);
    } else if(resType.isUnion()) {
      String typeName = typeAliasMap.containsKey(resType) ? 
          typeAliasMap.get(resType) : resType.getName();
      node1 = GNode.create("UnionTypeReference", null, typeName);
    } else {
      StringBuilder sb = new StringBuilder();
      String typeName = resType.toString();
      sb.append(Character.toUpperCase(typeName.charAt(0)));
      sb.append(typeName.substring(1));
      node1 = GNode.create(sb.toString());
    }
    
    Location loc = node.getLocation(); 
    node1.setLocation(loc);
    node1.setProperty(xtc.Constants.TYPE, resType);

    GNode node2 = GNode.create("SpecifierQualifierList", node1);
    node2.setLocation(loc);
    GNode node3 = GNode.create("TypeName", node2, null);
    node3.setLocation(loc);
    GNode node4 = GNode.create("SizeofExpression", node3);
    node4.setLocation(loc);
    return node4;
  }
  
  private CExpression getSubscriptExpression(CExpression region, CExpression subscript, Node node) {
    Location loc = node.getLocation();
    GNode node1 = (GNode) region.getSourceNode();
    GNode node2 = (GNode) subscript.getSourceNode();
    GNode node3 = GNode.create("SubscriptExpression", node1, node2);
    node1.setLocation(loc);
    node2.setLocation(loc);
    node3.setLocation(loc);
    return expressionOf(node3);
  }
  
  private int getDimofArray(Node node) {
    int dim = 0;
    while(node.getName().equals("ArrayDeclarator")) {
      dim++;
      node = node.getNode(0);
    }
    return dim;
  }
  
  private void initializeArray(CExpression var, GNode vals, int dimension, List<CExpression> indexList) {
    Location loc = vals.getLocation();
    if(vals.getName().equals("InitializerList")) {
      List<CExpression> exprList = visitInitializerList(vals);
      for(int i=0; i<exprList.size(); i++) {
        GNode val = (GNode) exprList.get(i).getSourceNode();
        GNode indexNode = GNode.create("IntegerConstant", ((Integer)i).toString());
        indexNode.setLocation(loc);
        indexList.add(0, expressionOf(indexNode));
        initializeArray(var, val, dimension, indexList);
        indexList.remove(0);
      }
    } else {
      assert(dimension == indexList.size());
      CExpression varWithIndex = var;
      for(int i=indexList.size()-1; i>=0; i--) {
        CExpression index = indexList.get(i);
        varWithIndex = getSubscriptExpression(varWithIndex, index, vals);
      }
      CExpression val = recurseOnExpression(vals);
      Statement stmt = Statement.assign(vals, varWithIndex, val);
      this.addStatementGlobalOrLocal(stmt);
    }
  }
  
  @Override
  public Object unableToVisit(Node node) {
    IOUtils
        .debug()
        .p("Ignoring unexpected node type: ")
        .pln(node.getName())
        .flush();
    return node;
  }

  public CExpression visitAdditiveExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(2));
    return expressionOf(node);
  }
  
  public CExpression visitMultiplicativeExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(2));
    return expressionOf(node);
  }

  public CExpression visitAddressExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    return CExpression.create(node,symbolTable.getCurrentScope());
  }

  public CExpression visitAssignmentExpression(GNode node) {
    Node lhsNode = node.getNode(0);
    String assignOperator = node.getString(1);
    Node rhsNode = node.getNode(2);
    
    boolean compSelect = 
        lhsNode.getName().equals("DirectComponentSelection") ||
        lhsNode.getName().equals("IndirectComponentSelection");
    
    boolean pointerAssign = lookupType(lhsNode).isPointer();
    
    boolean malloc = false;
    
    if( debugEnabled() ) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(lhsNode).p(
        " " + assignOperator + " ");
      
      IOUtils.debugC(rhsNode).pln().flush();
    }
    
    CExpression lhsExpr = recurseOnExpression(lhsNode);
    CExpression rhsExpr = recurseOnExpression(rhsNode);
    CExpression mallocVarExpr = null;
    
    Node rhsNodePrime = rhsExpr.getSourceNode();
    
    Statement resultStmt;

    /* Function call as x = f(x) should be operated differently */
    if(rhsNodePrime.getName().equals("FunctionCall")) {
      Node funNode = rhsNodePrime.getNode(0);
      
      /* Generate an allocated function for malloc function */
      if("malloc".equals(funNode.getString(0))) {
        malloc = true;
        Node sizeNode = rhsNodePrime.getNode(1).getNode(0);
        CExpression sizeExpr = recurseOnExpression(sizeNode);
        if(compSelect && pointerAssign) { /* s->firstName = malloc(sizeof(char)) */
          Node mallocVarNode = defineMallocVarNode(lhsNode);
          mallocVarExpr = CExpression.create(mallocVarNode, symbolTable.getCurrentScope());
          resultStmt = Statement.alloc(node, mallocVarExpr, sizeExpr);
        } else {
          resultStmt = Statement.alloc(node, lhsExpr, sizeExpr);
        }
      } else if("__NONDET__".equals(funNode.getString(0))) {
        resultStmt = Statement.havoc(node, lhsExpr);
      } else { /* For other function call, treat it as non-function call */
        if (!"=".equals(assignOperator)) {
          rhsExpr = CExpression.create(node,symbolTable.getCurrentScope());
        }
        resultStmt = Statement.assign(node, lhsExpr, rhsExpr);
      }
    }
    /* For other function call, as x = y, add assign statement */
    else { 
      /* The assignment operator may be one of +=, -=, et al., in which case the
       * rhs is the whole statement, e.g., x += y becomes something like (assign x
       * (x += y)) instead of (assign x (x+y)), because replacing the operator
       * here would be a PITA. It's up to the expression visitor to turn that into
       * an addition.
       */
      if (!"=".equals(assignOperator)) {
        rhsExpr = CExpression.create(node,symbolTable.getCurrentScope());
      }
      resultStmt = Statement.assign(node, lhsExpr, rhsExpr);
    }
    addStatementGlobalOrLocal(resultStmt);
    
    /* field assignment statement */
    if(compSelect && pointerAssign) {
      CExpression varExpr = recurseOnExpression(lhsNode.getNode(0));
      Node fieldNameNode = defineStringConstNode(lhsNode, lhsNode.getString(1));
      CExpression fieldName = CExpression.create(fieldNameNode, symbolTable.getCurrentScope());
      
      if(malloc) { /* s->firstName = malloc(sizeof(char)) */
        Statement assignStmt = Statement.assign(node, lhsExpr, mallocVarExpr);
        Statement fieldAssignStmt = Statement.fieldAssign(node, varExpr, fieldName, mallocVarExpr);
        addStatementGlobalOrLocal(assignStmt);
        addStatementGlobalOrLocal(fieldAssignStmt);
      } else {
        Statement fieldAssignStmt = Statement.fieldAssign(node, varExpr, fieldName, rhsExpr);
        addStatementGlobalOrLocal(fieldAssignStmt);
      }
    }
        
    return lhsExpr; // return the *value* of the assignment
  }

  public CExpression visitBitwiseAndExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(1));
    return expressionOf(node);
  }
  
  public CExpression visitBitwiseOrExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(1));
    return expressionOf(node);
  }

  public void visitBreakStatement(GNode node) {
    debug().loc(node).p(' ').indent().pln("break").flush();
    /* Add a skip as an anchor for the source line. */
    currentBlock.addStatement(Statement.skip(node));
    currentCfg.addEdge(currentBlock, getBreakTarget());

    /* This block will be a repository for dead code! 
     * TODO: Detect and eliminate vestigial blocks?
     */
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  }

  public void visitCaseLabel(GNode node) {
    Node val = node.getNode(0);

    debug()
        .loc(node)
        .p(' ')
        .decr()
        .indent()
        .p("case ");
    debugC(val)
        .pln(":")
        .incr()
        .flush();

    CExpression valExpr = recurseOnExpression(val);
    CaseGuard guard = new CaseGuard(getCaseExpression(), valExpr);
    currentCfg.addEdge(getSwitchEntry(), guard, currentBlock);
    addCaseGuard(guard);
  }

  public CExpression visitCastExpression(GNode node) {
    /* TODO: Deal with conversions */
    debug().pln("Treating cast as no-op.");
    return recurseOnExpression(node.getNode(1));
  }

  public CExpression visitCharacterConstant(GNode node) {
    return expressionOf(node);
  }
  
  public CExpression visitConditionalExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(1));
    recurseOnExpression(node.getNode(2));
    return expressionOf(node);
  }

  public void visitCommaExpression(GNode node) {
    for(Object o : node) {
      dispatch((Node) o);
    }
  }
  
  public void visitCompoundStatement(GNode node) {
    if(!compoStmtAsScope) {
      compoStmtAsScope = true;
      for (Object o : node) {
        dispatch((Node) o);
      }
    } else {
      enterScope(); 
      for (Object o : node) {
        dispatch((Node) o);
      }
      exitScope();
    }
  }

  public void visitContinueStatement(GNode node) {
    debug().loc(node).indent().pln("continue").flush();
    /* Add a skip as an anchor for the source line. */
    currentBlock.addStatement(Statement.skip(node));
    currentCfg.addEdge(currentBlock, getLoopEntry());

    /*
     * This block will be a repository for dead code! 
     * TODO: Detect and eliminate vestigial blocks?
     */
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  }

  public void visitDeclaration(GNode node) {
    Node type = node.getNode(1);
    Node declarations = node.getNode(2);
    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(type).p(' ');
      IOUtils.debugC(declarations).pln().flush();
    }
    if (declarations != null) {
      for (Object o : declarations) {
        dispatch((Node) o);
      }
    }
  }

  public void visitDefaultLabel(GNode node) {
    IOUtils
        .debug()
        .loc(node)
        .p(' ')
        .decr()
        .indent()
        .pln("default:")
        .incr()
        .flush();

    IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
    currentCfg.addEdge(getSwitchEntry(), guard, currentBlock);
    setHasDefault();
  }

  public CExpression visitEqualityExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(2));
    return CExpression.create(node, symbolTable.getCurrentScope()); // exprBuilder.visitEqualityExpression(node);
  }

  public List<CExpression> visitExpressionList(GNode node) {
    List<CExpression> subExprList = Lists.newArrayListWithCapacity(node.size());
    for (Object elem : node) {
      CExpression subExpr = recurseOnExpression((Node) elem);
      subExprList.add(subExpr);
    }
    return subExprList;
  }

  public void visitExpressionStatement(GNode node) {
    dispatch(node.getNode(0));
    flushPostStatements();
  }

  /* Do-nothing implementation to make errors from header files go away. */
  public CExpression visitFunctionDeclarator(GNode node) {
    // TODO: Something
    return CExpression.create(node,symbolTable.getCurrentScope());
  }
  
  public CExpression visitArrayDeclarator(GNode node) {
    CExpression baseExpr = (CExpression) dispatch(node.getNode(0));
    Node sizeNode = node.getNode(2);
    if(sizeNode == null)    return baseExpr;

    CExpression allocExpr = null;
    Node baseNode = baseExpr.getSourceNode();
      
    // Simple case: one-dime array int A[n]
    if("SimpleDeclarator".equals(baseNode.getName())) {
      Type cellType = lookupType(baseNode);
      
      /* Array declaration in parameter list: char A[5], A is with type
       * Pointer(Char), no need to add allocate statement for parameter.
       */
      if(!cellType.isArray())   return expressionOf(node);
       
      cellType = cellType.toArray();
      Node sizeTypeNode = getSizeofTypeNode(cellType, node);
      
      GNode multNode = GNode.create("MultiplicativeExpression", sizeNode, "*", sizeTypeNode);
      multNode.setLocation(node.getLocation()); // n * sizeof(int)
        
      GNode funcNode = GNode.create("PrimaryIdentifier", "array_allocated");
      funcNode.setLocation(node.getLocation()); // array_allocated(A, n * sizeof(int))
      
      GNode argList = GNode.create("ExpressionList", baseNode, multNode);
      argList.setLocation(node.getLocation());
        
      GNode allocNode = GNode.create("FunctionCall", funcNode, argList);
      allocNode.setLocation(node.getLocation());
      allocExpr = expressionOf(allocNode);
    } 
    // Complex case: multi-dim array int A[n][m]
    else if("FunctionCall".equals(baseNode.getName())) {
      Node lhsNode = baseNode.getNode(1).getNode(0);
      Node rhsNode = baseNode.getNode(1).getNode(1);
        
      GNode multNode = GNode.create("MultiplicativeExpression", sizeNode, "*", rhsNode);
      multNode.setLocation(node.getLocation());

      Node funcNode = GNode.create("PrimaryIdentifier", "array_allocated");
      funcNode.setLocation(node.getLocation());

      GNode argList = GNode.create("ExpressionList", lhsNode, multNode);
      argList.setLocation(node.getLocation());
        
      GNode allocNode = GNode.create("FunctionCall", funcNode, argList);
      allocNode.setLocation(node.getLocation());
      
      allocExpr = expressionOf(allocNode);
    } 
    return allocExpr;
  }
  
  /* NEWCHANGE: return a CExpression for Cfg */
  @SuppressWarnings("unchecked")
  public CExpression visitFunctionCall(GNode node) {
    Node funNode = node.getNode(0);
    Node argList = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent().p(funNode).p('(');
      if(argList != null) {
        Iterator<Object> argIter = argList.iterator();
        while (argIter.hasNext()) {
          Node arg = (Node) argIter.next();
          debug().p(arg);
          if (argIter.hasNext()) {
            debug().p(',');
          }
        }
      }
      debug().pln(')').flush();
    }
    CExpression funExpr;
    // [chris 1/8/2010] FIXME: avoid a lookup on the function name, since it
    // will probably return null
    if( "PrimaryIdentifier".equals(funNode.getName()) ) {
      funExpr = CExpression.create(funNode,symbolTable.getCurrentScope());
    } else {
      funExpr = recurseOnExpression(funNode);
    }
    List<CExpression> argExprs = (List<CExpression>) dispatch(argList);

    /*
     *  For special functions like "malloc" and "free", we treat them differently
     *  1) malloc: just return the expression, do not add statement wait for the 
     *  visitAssignmentExpression to do that, since in malloc(x), we just know 
     *  the size "x", but the regionName cannot be known until return to the assign
     *  statement as y = malloc(x). Then we could add alloc(y, x)) by calling the 
     *  internal function alloc(...).
     *  2) free: could add statement directly as free(x)
     *  3) for others, add functionCall statement, we'll do the real calling as pick
     *  the cfg of the function in the RunProcessor.java
     */
    
    String funcName = funNode.getString(0);
    if("malloc".equals(funcName)) {
    } else if("__NONDET__".equals(funcName)) {
    } else if("free".equals(funcName)) {
      addStatement(Statement.free(node, expressionOf(node.getNode(1).getNode(0))));
    } else {
      if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
        if("ASSERT".equals(funcName)) {
          addStatement(Statement.assertStmt(node, expressionOf(node.getNode(1).getNode(0))));
        } else if("ASSUME".equals(funcName)) {
          addStatement(Statement.assumeStmt(node, expressionOf(node.getNode(1).getNode(0))));
        } else if("INVARIANT".equals(funcName)) {
          addStatement(Statement.assumeStmt(node, expressionOf(node.getNode(1).getNode(0))));
          addStatement(Statement.assertStmt(node, expressionOf(node.getNode(1).getNode(0))));
        } else {
          addStatement(Statement.functionCall(node, funExpr, argExprs));
        } 
      } else {
        addStatement(Statement.functionCall(node, funExpr, argExprs));
      }
    }
    return expressionOf(node);
  }

  public void visitDoStatement(GNode node) {
    Node test = node.getNode(1);
    Node body = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" while(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }

    GNode assignNode = GNode.create("AssignmentExpression", defineTestVarNode(test), "=", test);
    assignNode.setLocation(test.getLocation());
    CExpression assignExpr = recurseOnExpression(assignNode);

    Guard ifBranch = Guard.create(assignExpr);
    Guard elseBranch = ifBranch.negate();

    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), 
            symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    pushScope(entryBlock, exitBlock);

    currentCfg.addEdge(currentBlock, entryBlock);
    currentCfg.addEdge(entryBlock, ifBranch, bodyBlock);
    currentCfg.addEdge(bodyBlock, entryBlock);
    currentCfg.addEdge(entryBlock, elseBranch, exitBlock);
    
    /* Add the statements to the current block */
    addAndFlushPostStatements(entryBlock);
    
    currentBlock = bodyBlock;
    dispatch(body);
    closeCurrentBlock(entryBlock);  // close the loop
    currentBlock = exitBlock;  // exit the loop
    popScope();

    if( debugEnabled() ) {
      popAlign();
      debug().decr().flush();
    }
  }
  
  public void visitFunctionDefinition(GNode node) {
    // Node is: FunctionDefinition(type modifiers, type signature (including
    // id), locals, body)
    final GNode returnType = node.getGeneric(1);

    final GNode declarator = node.getGeneric(2);
    final GNode identifier = CAnalyzer.getDeclaredId(declarator);
    final String functionName = identifier.getString(0);
    
    GNode parameters = CAnalyzer.getFunctionDeclarator(declarator).getGeneric(1);
    if( parameters != null ) {
      parameters = parameters.getGeneric(0);
    }
    
    // FunctionDefiniion node has 'scope' property, here enter the scope
    // directly, ignore the following compoundStatement; it means no need
    // to enter scope there, set 'CompoStmtAsScope' as 'false'
    enterScope(node);
    compoStmtAsScope = false;

    if (parameters != null) {
      for (Object o : parameters) {
        assert (o instanceof Node);
        assert ("ParameterDeclaration".equals(((Node) o).getName()));
        // Drill down to the actual declaration
        dispatch(((Node) o).getNode(1));
      }
    }
    
    currentCfg = new ControlFlowGraph(node, functionName, symbolTable
        .getCurrentScope());
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    currentCfg.addEdge(currentCfg.getEntry(), currentBlock);

    flushScopes();
    pushScope(currentBlock, currentCfg.getExit());

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      IOUtils.debugC(returnType).p(' ');
      IOUtils.debugC(declarator).pln(" {").incr().flush();
    }
    
    postStatements = Lists.newLinkedList();
    appendStatements = Lists.newArrayList();
    expressionDepth = 0;

    // recurse on the function body
    final GNode body = node.getGeneric(4);
    dispatch(body);

    currentCfg.addEdge(currentBlock, currentCfg.getExit());

    cfgs.put(node, currentCfg);

    if( debugEnabled() ) {
      popAlign();
      debug().decr().pln("} // end function").flush().reset();
      currentCfg.format(debug());
    }
    exitScope();
  }

  public void visitGotoStatement(GNode node) {
    Node labelNode = node.getNode(1);
    assert labelNode.getName().equals("PrimaryIdentifier") : 
      "CfgBuilder::visitGotoStatement - " + "invalid label.";
    recurseOnExpression(labelNode);
    String label = labelNode.getString(0);
    BasicBlock labelBlock = labeledBlocks.get(label);
    currentCfg.addEdge(currentBlock, labelBlock);
    currentBlock = labelBlock;
  }
  
  public void visitIfElseStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);
    Node elsePart = node.getNode(2);

    if( debugEnabled() ) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().indent().p("if(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }
    
    GNode assignNode = GNode.create("AssignmentExpression", defineTestVarNode(test), "=", test);
    assignNode.setLocation(test.getLocation());
    CExpression assignExpr = recurseOnExpression(assignNode);

    Guard ifBranch = Guard.create(assignExpr);
    Guard elseBranch = ifBranch.negate();

    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock ifBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock elseBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    currentCfg.addEdge(entryBlock, ifBranch, ifBlock);
    currentCfg.addEdge(entryBlock, elseBranch, elseBlock);

    /* Add the location of the conditional test to the current block */
    entryBlock.addLocation(assignExpr.getLocation());
    /* Add the statements to the current block */
    addAndFlushPostStatements(entryBlock);
    
    currentBlock = ifBlock;
    dispatch(ifPart);
    closeCurrentBlock(exitBlock);

    if( debugEnabled() ) {
      peekAlign();
      debug().p(' ').decr().indent().pln("else").incr().flush();
    }
    
    currentBlock = elseBlock;
    dispatch(elsePart);
    closeCurrentBlock(exitBlock);
    currentBlock = exitBlock;

    if( debugEnabled() ) {
    popAlign();
    debug().decr().pln("}").flush();
    }
  }

  public void visitIfStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent().p("if(");
      debugC(test).pln(")").incr().flush();
    }
    
    GNode assignNode = GNode.create("AssignmentExpression", defineTestVarNode(test), "=", test);
    assignNode.setLocation(test.getLocation());
    CExpression assignExpr = recurseOnExpression(assignNode);

    Guard ifBranch = Guard.create(assignExpr);
    Guard elseBranch = ifBranch.negate();
    
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock ifBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    currentCfg.addEdge(entryBlock, ifBranch, ifBlock);
    currentCfg.addEdge(entryBlock, elseBranch, exitBlock);
    
    /* Add the location of the conditional test to the current block */
    currentBlock.addLocation(assignExpr.getLocation());
    /* Add the statements to the current block */
    addAndFlushPostStatements(entryBlock);

    currentBlock = ifBlock;
    dispatch(ifPart);
    closeCurrentBlock(exitBlock);
    currentBlock = exitBlock;

    debug().decr().flush();
  }

  CExpression expressionOf(Node node) {
    return CExpression.create(node, symbolTable.getCurrentScope());
  }

  public CExpression visitIndirectionExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    return expressionOf(node);
    // exprBuilder.visitIndirectionExpression(node);
  }

  public void visitInitializedDeclarator(GNode node) {
    /* If there is an initializer, add as an assignment statement */    
    Node varNode = node.getNode(1);
    CExpression varExpr = recurseOnExpression(varNode);
    Statement stmt;
    
    if ("ArrayDeclarator".equals(varNode.getName())) {
      if(!isAliasName(varNode.getNode(0))) {
        Node varNodePrime = varExpr.getSourceNode();
        CExpression baseExpr = expressionOf(varNodePrime.getNode(1).getNode(0));
        CExpression sizeExpr = expressionOf(varNodePrime.getNode(1).getNode(1));
        Statement declareStmt = Statement.declareArray(varNodePrime, baseExpr, sizeExpr);
        addStatementGlobalOrLocal(declareStmt);
        if(null != node.get(4)) {
          GNode valNodeList = node.getGeneric(4);
          assert("InitializerList".equals(valNodeList.getName()));
          int dimension = getDimofArray(varNode);
          List<CExpression> indexExprList = Lists.newArrayList();
          initializeArray(baseExpr, valNodeList, dimension, indexExprList);
        }
      }
    } else {
      if("SimpleDeclarator".equals(varNode.getName())) {
        Node varNodePrime = varExpr.getSourceNode();
        Type varType = unwrapped(lookupType(varNodePrime));
        if(varType.isStruct() || varType.isUnion()) {
          if(!isAliasName(varNode)) {
            Node sizeNode = getSizeofTypeNode(varType, varNode);
            CExpression sizeExpr = expressionOf(sizeNode);
            Statement declareStmt = Statement.declareStruct(node, varExpr, sizeExpr);
            addStatementGlobalOrLocal(declareStmt);
          }
        }
      }
      /* Assignment expression is included here, e.g. "int a = 1;" */
      if (node.get(4) instanceof Node) {
        Node valNode = node.getNode(4);
        CExpression valExpr = recurseOnExpression(valNode);
        Node valNodePrime = valExpr.getSourceNode();
        if("FunctionCall".equals(valNodePrime.getName())) {
          Node funNode = valNodePrime.getNode(0);  
          /* Generate an allocated function for malloc function */
          if("malloc".equals(funNode.getString(0))) {
            Node sizeNode = valNodePrime.getNode(1).getNode(0);
            CExpression sizeExpr = expressionOf(sizeNode);            
            stmt = Statement.alloc(node, varExpr, sizeExpr);
          } else if("__NONDET__".equals(funNode.getString(0))) {        
            stmt = Statement.havoc(node, varExpr);
          } else {
            stmt = Statement.assign(node, varExpr, valExpr);
          }
        } else {
          stmt = Statement.assign(node, varExpr, valExpr);
        }
        addStatementGlobalOrLocal(stmt);
      }
    }
  }

  public List<CExpression> visitInitializerList(GNode node) {
    List<CExpression> subExprList = Lists.newArrayListWithCapacity(node.size());
    for (Object elem : node) {
      CExpression subExpr = recurseOnExpression((Node) elem);
      subExprList.add(subExpr);
    }
    return subExprList;
  }

  public CExpression visitInitializerListEntry(GNode node) {
    CExpression valExpr = expressionOf(node.getNode(1));
    return valExpr;
  }
  
  public CExpression visitIntegerConstant(GNode node) {
    return expressionOf(node);
  }
  
  public CExpression visitFloatingConstant(GNode node) {
    return expressionOf(node);
  }

  public void visitLabeledStatement(GNode node) {
    Node label = node.getNode(0);
    Node stmt = node.getNode(1);
    
    BasicBlock labelStmt = currentCfg.newBlock(symbolTable.getCurrentScope());

    if("NamedLabel".equals(label.getName())) {
      String labelName = label.getString(0);
      this.labeledBlocks.put(labelName, labelStmt);
      currentCfg.addEdge(currentBlock, labelStmt);
    } else if("CaseLabel".equals(label.getName())) {
      CExpression testExpr = getCaseExpression();
      CExpression caseLabel = recurseOnExpression(label.getNode(0));
      CaseGuard caseBranch = new CaseGuard(testExpr, caseLabel);
      setCaseGuard(caseBranch);
      currentCfg.addEdge(currentBlock, caseBranch, labelStmt);
    } else if("DefaultLabel".equals(label.getName())) {
      setHasDefault();
      IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
      currentCfg.addEdge(currentBlock, guard, labelStmt);
    }
    currentBlock = labelStmt;
    dispatch(stmt);
  }

  public CExpression visitLogicalAndExpression(GNode node) {
    /* Deal with side-effects */
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(1));
    return expressionOf(node);
  }

  /* NEWADD: visitLogicalOrExpression */
  public CExpression visitLogicalOrExpression(GNode node) {
    /* Deal with side-effects */
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(1));
    return expressionOf(node);
  }

  public CExpression visitLogicalNegationExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    return expressionOf(node);
  }

  public CExpression visitSizeofExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    return expressionOf(node);
  }

  public CExpression visitTypeName(GNode node) {
    recurseOnExpression(node.getNode(0));
    // recurseOnExpression(node.getNode(1));
    return expressionOf(node);
  }

  public CExpression visitSpecifierQualifierList(GNode node) {
    return expressionOf(node);
  }

  public CExpression visitDirectComponentSelection(GNode node) {
    recurseOnExpression(node.getNode(0));
    return expressionOf(node);
  }

  public CExpression visitIndirectComponentSelection(GNode node) {
    recurseOnExpression(node.getNode(0));
    return expressionOf(node);
  }
  
  public CExpression visitPostdecrementExpression(GNode node) {
    Node opNode = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" - 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");
    oneNode.setLocation(opNode.getLocation());
    GNode decNode = GNode.create("AdditiveExpression", opNode, "-", oneNode);
    decNode.setLocation(opNode.getLocation());
    Statement stmt = Statement.assign(node, opExpr, CExpression.create(decNode, opExpr.getScope()));
    if(expressionDepth == 0)       addStatement(stmt);
    else                           appendStatements.add(stmt);

    return opExpr; // return the *prior value* of the operand
  }
  
  public CExpression visitPostincrementExpression(GNode node) {
    Node opNode = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" + 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");
    oneNode.setLocation(opNode.getLocation());
    GNode incNode = GNode.create("AdditiveExpression", opNode, "+", oneNode);
    incNode.setLocation(opNode.getLocation());
    Statement stmt = Statement.assign(node, opExpr, CExpression.
        create(incNode, opExpr.getScope()));
    if(expressionDepth == 0)       addStatement(stmt);
    else                           appendStatements.add(stmt);

    return opExpr; // return the *prior value* of the operand
  }

  public CExpression visitPredecrementExpression(GNode node) {
    Node opNode = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" - 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");
    oneNode.setLocation(opNode.getLocation());
    GNode decNode = GNode.create("AdditiveExpression", opNode, "-", oneNode);
    decNode.setLocation(opNode.getLocation());
    addStatement(Statement.assign(node, opExpr, CExpression
        .create(decNode, opExpr.getScope())));

    return opExpr; // return the *prior value* of the operand
  }  
  
  public CExpression visitPreincrementExpression(GNode node) {
    Node opNode = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" + 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");
    oneNode.setLocation(opNode.getLocation());
    GNode incNode = GNode.create("AdditiveExpression", opNode, "+", oneNode);
    incNode.setLocation(opNode.getLocation());
    addStatement(Statement.assign(node, opExpr, CExpression
        .create(incNode, opExpr.getScope())));

    return opExpr; // return the *prior value* of the operand
  } 
  
  public CExpression visitPointerDeclarator(GNode node) {
    return (CExpression) dispatch(node.getNode(1));
  }

  public CExpression visitPrimaryIdentifier(GNode node) {
    return getVarBinding(node);
  }

  public CExpression visitSimpleDeclarator(GNode node) {
    String name = (String) node.get(0);
    debug().pln(
        "Looking up binding for variable: " + name + " in symbol table "
            + symbolTable);
    assert (symbolTable.isDefined(name));
    assert (symbolTable.getCurrentScope().equals(symbolTable.lookupScope(name)));
    /*
     * TODO: Interpret type and choose appropriate IRType. Non-null source node?
     */
    IRVarInfo varInfo = new VarInfo(symbolTable.getCurrentScope(), name,
        IRIntegerType.getInstance(), node);
    debug().pln("Binding: " + varInfo);
    symbolTable.undefine(name);
    symbolTable.define(name, varInfo);
    if(!node.hasProperty(xtc.Constants.TYPE))
      node.setProperty(xtc.Constants.TYPE, symbolTable.lookupType(node.getString(0)).resolve());
    return expressionOf(node);
  }

  private CExpression getVarBinding(Node node) {
    String name = (String) node.get(0);
    debug().pln(
        "Looking up binding for variable: " + name + " in symbol table "
            + symbolTable);
    IRVarInfo binding = symbolTable.lookup(name);
    debug().pln("Binding: " + binding).flush();
    return expressionOf(node);
  }

  public CExpression visitRelationalExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(2));
    return expressionOf(node);
  }

  public void visitReturnStatement(GNode node) {
    if( debugEnabled() ) {
      IOUtils
        .debug()
        .loc(node)
        .p(' ')
        .indent()
        .p("return ");
      IOUtils.debugC(node.getNode(0))
        .pln()
        .flush();
    }
    CExpression val = recurseOnExpression(node.getNode(0));

    /*
     * NOTE: there may be reachable statements after a return statement in the
     * CFG. For example, "return i++" will be dismantled to "return i; i++".
     */
    addStatement(Statement.returnStmt(node, val));
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
  }

  public CExpression visitStringConstant(GNode node) {
    // pick the content to create a node for initialization
    String nullStr = "\u0000";
    String content = node.getString(0);
    if(content.equals(nullStr)) {
      int constVal = 0;
      GNode charConst = GNode.create("CharacterConstant", "\'\\u0000\'");
      charConst.setLocation(node.getLocation());
      Type t = (new xtc.type.AnnotatedT(NumberT.CHAR)).constant(constVal);
      charConst.setProperty(xtc.Constants.TYPE, t);
      return expressionOf(charConst);
    }
        
    char[] contentArr = node.getString(0).substring(1).toCharArray(); // content = [", 1, 2, 3, "]
    Pair<Object> operands = null;
    for(int i=0; i<contentArr.length; i++) {
      String str = null;
      long constVal;
      if(i == contentArr.length - 1) {
        str = "\'\\u0000\'";
        constVal = 0;
      } else {
        str = new StringBuilder().append('\'').append(contentArr[i]).append('\'').toString();
        constVal = (int) contentArr[i];
      }
      // Here, we translate the single character to the char with ASCII code.
      GNode charConst = GNode.create("CharacterConstant", str);
      charConst.setLocation(node.getLocation());
      Type t = (new xtc.type.AnnotatedT(NumberT.CHAR)).constant(constVal);
      charConst.setProperty(xtc.Constants.TYPE, t);
      GNode initEntry = GNode.create("InitializerListEntry", null, charConst);
      initEntry.setLocation(node.getLocation());
      if(i == 0)    operands = new Pair<Object>(initEntry);
      else          operands = operands.append(new Pair<Object>(initEntry));
    }
    
    GNode initListNode = GNode.createFromPair("InitializerList", operands);
    
    // string variable
    Node stringVarNode = defineStringVarNode(node);
    CExpression stringVarExpr = expressionOf(stringVarNode);
    
    // length * sizeof(char)
    GNode lhsNode = GNode.create("IntegerConstant", Integer.toString(contentArr.length));
    lhsNode.setLocation(node.getLocation());   
    Node rhsNode = getSizeofTypeNode(IntegerT.CHAR, node);
    GNode sizeNode = GNode.create("MultiplicativeExpression", lhsNode, "*", rhsNode);
    sizeNode.setLocation(node.getLocation());
    CExpression sizeExpr = expressionOf(sizeNode);
    
    // string_allocated(STRING_VAR_*, length * sizeof(char))   
    Statement declareStmt = Statement.declareArray(node, stringVarExpr, sizeExpr);
    addStatementGlobalOrLocal(declareStmt);
    
    List<CExpression> indexExprList = Lists.newArrayList();
    initializeArray(stringVarExpr, initListNode, 1, indexExprList);
    return stringVarExpr;
  }

  public void visitSwitchStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    debug().loc(node).p(' ');
    pushAlign();
    debug()
        .indent()
        .p("switch(");
    debugC(test)
        .pln(")")
        .incr()
        .incr()
        .flush();

    CExpression testExpr = recurseOnExpression(test);

    // TODO: handle side effects in test expression
    // Create side-effect block and duplicate for every case?

    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), 
            symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    pushScope(entryBlock, exitBlock, testExpr);
    currentCfg.addEdge(currentBlock, entryBlock);
    currentBlock = entryBlock;
    currentCfg.addEdge(currentBlock, bodyBlock);

    for(Object o : body) {
      if(o != null) {
        if("LabeledStatement".equals(((Node) o).getName())) {
          currentBlock = bodyBlock;
          dispatch((Node) o);
          if(hasDefault())  // FIXME: how about add break in default case
            closeCurrentBlock(exitBlock);          
        } else if("BreakStatement".equals(((Node) o).getName())) {
          dispatch((Node) o);
          closeCurrentBlock(exitBlock);
        } else {
          dispatch((Node) o);
        }
      }
    }

    currentBlock = exitBlock;

    if (!hasDefault()) {
      IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());

      currentCfg.addEdge(entryBlock, guard, exitBlock);
    }

    popScope();
    popAlign();
    debug().decr().flush();
  }

  public CExpression visitSubscriptExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    recurseOnExpression(node.getNode(1));
    /* Tag type to the node */
    Type childType;
    childType = lookupType(node.getNode(0));
    if(childType.isPointer())  
      node.setProperty(xtc.Constants.TYPE, childType.toPointer().getType());
    if(childType.isArray())
      node.setProperty(xtc.Constants.TYPE, childType.toArray().getType());
    return expressionOf(node);
  }
  
  public CExpression visitShiftExpression(GNode node) {
    return expressionOf(node);
  }

  /** Visit the specified translation unit. */
  public Map<Node, ? super ControlFlowGraph> visitTranslationUnit(GNode n) {
    cfgs.clear();
    for (Object o : n) {
      dispatch((Node) o);
    }
    return cfgs;
  }

  public CExpression visitUnaryMinusExpression(GNode node) {
    recurseOnExpression(node.getNode(0));
    return expressionOf(node);
  }

  public void visitWhileStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" while(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }

    GNode assignNode = GNode.create("AssignmentExpression", defineTestVarNode(test), "=", test);
    assignNode.setLocation(test.getLocation());
    CExpression assignExpr = recurseOnExpression(assignNode);

    Guard ifBranch = Guard.create(assignExpr);
    Guard elseBranch = ifBranch.negate();
    
    xtc.util.SymbolTable.Scope currentScope = symbolTable.getCurrentScope();
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), currentScope);
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getScope(body));
    BasicBlock exitBlock = currentCfg.newBlock(currentScope);

    pushScope(entryBlock, exitBlock);
    
    Node invariant = body.getNode(0).getNode(0);
    if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION) 
        && invariant != null
        && invariant.getName().equals("FunctionCall") 
        && invariant.getNode(0).getString(0).equals("INVARIANT")) {
      BasicBlock invariantBlock = currentCfg.newBlock(symbolTable.getScope(body));
      
      body = body.getNode(1);
      
      currentCfg.addEdge(currentBlock, entryBlock);
      currentCfg.addEdge(entryBlock, ifBranch, bodyBlock);
      currentCfg.addEdge(bodyBlock, elseBranch, exitBlock);
      
      /* Add the statements to the current block */
      addAndFlushPostStatements(entryBlock);
      
      currentBlock = bodyBlock;
      dispatch(body);
      currentBlock = invariantBlock;
      dispatch(invariant);
      
      List<IRStatement> invStmts = invariantBlock.getStatements();
      IRStatement assumeStmt = invStmts.get(0);
      IRStatement assertStmt = invStmts.get(1);
      
      ImmutableList<IRStatement> stmts = new ImmutableList.Builder<IRStatement>()
          .addAll(bodyBlock.getStatements()).build();
      
      Iterable<IRStatement> havocStmts = Iterables.transform(
          Iterables.filter(stmts, new Predicate<IRStatement>(){
            @Override
            public boolean apply(IRStatement stmt) {
              return stmt.getType() == StatementType.ASSIGN;
            }
          }), 
          new Function<IRStatement, IRStatement>() {
            @Override
            public IRStatement apply(IRStatement stmt) {
              IRExpressionImpl lval = (IRExpressionImpl) ((Statement) stmt).getOperand(0);
              return Statement.havoc(lval.getSourceNode(), lval);
            }
          }
          );
      
      ImmutableList<IRStatement> preStmts = new ImmutableList.Builder<IRStatement>()
          .add(assertStmt).addAll(havocStmts).add(assumeStmt).build();
      
      ImmutableList<IRStatement> testStmts = entryBlock.getStatements();
      
      entryBlock.addStatements(0, preStmts);
      
      bodyBlock.addStatement(assertStmt);
      bodyBlock.addStatements(testStmts);
    } else {
      currentCfg.addEdge(currentBlock, entryBlock);
      currentCfg.addEdge(entryBlock, ifBranch, bodyBlock);
      currentCfg.addEdge(entryBlock, elseBranch, exitBlock);
      
      /* Add the statements to the current block */
      addAndFlushPostStatements(entryBlock);
      
      currentBlock = bodyBlock;
      dispatch(body);
      currentCfg.addEdge(currentBlock, entryBlock);
    }
    
    closeCurrentBlock(entryBlock); // close the loop
    currentBlock = exitBlock;
    popScope();
    
    if( debugEnabled() ) {
      popAlign();
      debug().decr().flush();
    }
  }
  
  public void visitForStatement(GNode node) {
    Node init = node.getNode(0);
    Node test = node.getNode(1);
    Node incr = node.getNode(2);
    Node body = node.getNode(3);
    
    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" for(");
      IOUtils.debugC(init).p("; ");
      IOUtils.debugC(test).p("; ");
      IOUtils.debugC(incr).pln(")").incr().flush();
    }
    
    // ForStatement node has 'scope' property, here enter the scope directly,
    // ignore the following compoundStatement; it means no need to enter scope
    // there, set 'CompoStmtAsScope' as 'false'
    enterScope(node);
    compoStmtAsScope = false;
    
    GNode assignNode = GNode.create("AssignmentExpression", defineTestVarNode(test), "=", test);
    assignNode.setLocation(test.getLocation());
    CExpression assignExpr = recurseOnExpression(assignNode);

    Guard ifBranch = Guard.create(assignExpr);
    Guard elseBranch = ifBranch.negate();
    
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), 
            symbolTable.getCurrentScope());
    BasicBlock initBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock incrBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    pushScope(initBlock, exitBlock);
    
    if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)
        && body.getNode(0) != null
        && body.getNode(0).getNode(0) != null
        && body.getNode(0).getNode(0).getName().equals("FunctionCall") 
        && body.getNode(0).getNode(0).getNode(0).getString(0).equals("INVARIANT")) {
      BasicBlock invariantBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
      Node invariant = body.getNode(0).getNode(0);
      body = body.getNode(1);
      
      currentCfg.addEdge(currentBlock, initBlock);
      currentCfg.addEdge(initBlock, entryBlock);
      currentCfg.addEdge(entryBlock, ifBranch, bodyBlock);
      currentCfg.addEdge(bodyBlock, incrBlock);
      currentCfg.addEdge(incrBlock, elseBranch, exitBlock);
      
      /* Add the statements to the current block */
      addAndFlushPostStatements(entryBlock);
      
      currentBlock = initBlock;   
      dispatch(init);
      currentBlock = bodyBlock;
      dispatch(body);
      currentBlock = incrBlock;
      dispatch(incr);
      currentBlock = invariantBlock;
      dispatch(invariant);
      
      List<IRStatement> invStmts = invariantBlock.getStatements();
      IRStatement assumeStmt = invStmts.get(0);
      IRStatement assertStmt = invStmts.get(1);
      
      ImmutableList<IRStatement> stmts = new ImmutableList.Builder<IRStatement>()
          .addAll(bodyBlock.getStatements())
          .addAll(incrBlock.getStatements()).build();
      Iterable<IRStatement> havocStmts = Iterables.transform(
          Iterables.filter(stmts, new Predicate<IRStatement>(){
            @Override
            public boolean apply(IRStatement stmt) {
              return stmt.getType() == StatementType.ASSIGN;
            }
          }), 
          new Function<IRStatement, IRStatement>() {
            @Override
            public IRStatement apply(IRStatement stmt) {
              IRExpressionImpl lval = (IRExpressionImpl) ((Statement) stmt).getOperand(0);
              return Statement.havoc(lval.getSourceNode(), lval);
            }
          }
          );
      
      ImmutableList<IRStatement> preStmts = new ImmutableList.Builder<IRStatement>()
          .add(assertStmt).addAll(havocStmts).add(assumeStmt).build();
      
      ImmutableList<IRStatement> testStmts = entryBlock.getStatements();
      
      entryBlock.addStatements(0, preStmts);
      
      incrBlock.addStatement(assertStmt);
      incrBlock.addStatements(testStmts);
    } else {
      currentCfg.addEdge(currentBlock, initBlock);
      currentCfg.addEdge(initBlock, entryBlock);
      currentCfg.addEdge(entryBlock, ifBranch, bodyBlock);
      currentCfg.addEdge(incrBlock, entryBlock);
      currentCfg.addEdge(entryBlock, elseBranch, exitBlock);
      
      /* Add the statements to the current block */
      addAndFlushPostStatements(entryBlock);

      currentBlock = initBlock;   
      dispatch(init);
      currentBlock = bodyBlock;
      dispatch(body);
      currentCfg.addEdge(currentBlock, incrBlock);
      currentBlock = incrBlock;
      dispatch(incr);
    }
    
    closeCurrentBlock(initBlock); // close the loop
    currentBlock = exitBlock;
    popScope();

    if( debugEnabled() ) {
        popAlign();
        debug().decr().flush();
    }   
    exitScope();
  }
}
