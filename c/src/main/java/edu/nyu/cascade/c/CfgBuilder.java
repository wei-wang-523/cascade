package edu.nyu.cascade.c;

import static edu.nyu.cascade.util.IOUtils.debug;
import static edu.nyu.cascade.util.IOUtils.debugC;
import static edu.nyu.cascade.util.IOUtils.debugEnabled;
import hidden.org.codehaus.plexus.interpolation.util.StringUtils;

import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import xtc.tree.*;
import xtc.type.*;

import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import edu.nyu.cascade.ir.IRBooleanExpression;
import edu.nyu.cascade.ir.IRControlFlowGraph;
import edu.nyu.cascade.ir.IRLocations;
import edu.nyu.cascade.ir.IRVarInfo;
import edu.nyu.cascade.ir.SymbolTable;
import edu.nyu.cascade.ir.expr.ExpressionFactoryException;
import edu.nyu.cascade.ir.impl.BasicBlock;
import edu.nyu.cascade.ir.impl.CaseGuard;
import edu.nyu.cascade.ir.impl.ControlFlowGraph;
import edu.nyu.cascade.ir.impl.DefaultCaseGuard;
import edu.nyu.cascade.ir.impl.Guard;
import edu.nyu.cascade.ir.impl.Statement;
import edu.nyu.cascade.ir.impl.VarInfoFactory;
import edu.nyu.cascade.util.IOUtils;
import edu.nyu.cascade.util.Identifiers;
import edu.nyu.cascade.util.Pair;
import edu.nyu.cascade.util.Preferences;
import edu.nyu.cascade.util.ReservedFunction;

/**
 * A CFG builder for ASTs generated by <code>edu.nyu.cascade.c.CParser</code>. A
 * typical client should just call <code>getCfgs</code> to extract CFGs from the
 * AST for a compilation unit.
 * 
 * <em>Note for implementers:</em> To add support for a parse rule Foo, add a
 * method <code>T visitFoo(Node n)</code>, where <code>T</code> is a type of
 * your choosing (or <code>void</code>). See the documentation for
 * <code>xtc.tree.Visitor</code> for more information.
 */
public class CfgBuilder extends Visitor {
  
  /**
   * Retrieve the CFGs from the given parse tree, using the given symbol table
   * and expression manager.
   * 
   * @param symbolTable
   *          The symbol table to use for symbols defined and used in the parse
   *          tree.
   * @param ast
   *          A <code>edu.nyu.cascade.c.CParser</code> compilation unit AST
   *          node.
   * @return A <code>Map</code> from declaration nodes to CFGs.
   */
  @SuppressWarnings("unchecked")
  public static Map<Node, IRControlFlowGraph> getCfgs(SymbolTable symbolTable, CAnalyzer cAnalyzer,
      Node ast) {
    return (Map<Node, IRControlFlowGraph>) new CfgBuilder(symbolTable, cAnalyzer).dispatch(ast);
  }
  
  public static CExpression analyze(SymbolTable symbolTable, CAnalyzer cAnalyzer, Node node) {
  	cAnalyzer.analyze(node, symbolTable.getOriginalSymbolTable());
  	CfgBuilder cfgBuilder = new CfgBuilder(symbolTable, cAnalyzer);
  	cfgBuilder.isCollectStmts = false;
  	return (CExpression) cfgBuilder.dispatch(node);
  }

  /**
   * A Scope is either a loop or a switch statement. We distinguish the two by
   * setting caseExpr to non-null. If non-null, it represents the argument E of
   * a switch statement "switch(E) { ... }".
   */
  private static class Scope {
    private final BasicBlock entry, exit;
    private final CExpression caseExpr;
    private final List<CaseGuard> caseGuards;
    private boolean hasDefault;

    public Scope(BasicBlock entry, BasicBlock exit) {
      this(entry, exit, null);
    }

    public Scope(BasicBlock entry, BasicBlock exit, CExpression caseExpr) {
      this.entry = entry;
      this.exit = exit;
      this.caseExpr = caseExpr;
      this.caseGuards = Lists.newArrayList();
      this.hasDefault = false;
    }

    public CExpression getCaseExpr() {
      return caseExpr;
    }

    public BasicBlock getEntry() {
      return entry;
    }

    public BasicBlock getExit() {
      return exit;
    }

    public void addCaseGuard(CaseGuard g) {
      caseGuards.add(g);
    }

    public List<CaseGuard> getCaseGuards() {
      return caseGuards;
    }

    public boolean hasDefault() {
      return hasDefault;
    }

    public void setHasDefault() {
      hasDefault = true;
    }
  }
  
  private static final Predicate<Node> isMalloc = new Predicate<Node>() {
  	@Override
  	public boolean apply(Node node) {
  		if(node.hasName("CastExpression")) node = node.getNode(1);
  		if(!node.hasName("FunctionCall")) return false;
  		String funcName = node.getNode(0).getString(0);
  		return ReservedFunction.MALLOC.equals(funcName);
  	}
  };
  
  private BasicBlock currentBlock;
  private List<Statement> postStatements, appendStatements;
  private Deque<Integer> alignments;  // for pretty-printing

	/**
   * Greater than 0 if the visitor is currently inside an expression, as opposed
   * to a statement. Allows us to distinguish between "statement expressions"
   * that embedded in larger expressions, so we can properly order effects.
   * E.g., while processing if( (n = cp++) == 0 ), expressionDepth will be 1
   * when the visitor reaches the assignment operator, so that we know the
   * assignment expression is a side effect of the expression, and not a
   * first-class statement.
   * 
   * Should be incremented by every expression visited and decremented when the
   * visitor returns.
   */
  private int expressionDepth;
  private ControlFlowGraph currentCfg;

	private final SymbolTable symbolTable;
	private final Map<Node, ControlFlowGraph> cfgs;
  private final Deque<Scope> scopes;
  private final CAnalyzer cAnalyzer;
  private final Map<Pair<String, ControlFlowGraph>, BasicBlock> labeledBlocks;
  
  /**
   * It is true if CFG-builder is used to collect statements, otherwise,
   * CFG-builder is used to analyze commands in the control file
   */
  private boolean isCollectStmts = true;
  
  private CfgBuilder(SymbolTable symbolTable, CAnalyzer cAnalyzer) {
    this.symbolTable = symbolTable;
    this.cAnalyzer = cAnalyzer;
    alignments = Lists.newLinkedList();
    cfgs = Maps.newHashMap();
    scopes = Lists.newLinkedList();
    labeledBlocks = Maps.newHashMap();
  }

  /** Align the debug output with the last seen tab stop. */
  private void peekAlign() {
    if( debugEnabled() ) {
      debug().align(alignments.peek());
    }
  }

  /** Align the debug output with the last tab stop and discard it. */
  private void popAlign() {
    if( debugEnabled() ) {
      debug().align(alignments.remove());
    }
  }

  /** Push a tab stop. */
  private void pushAlign() {
    if( debugEnabled() ) {
      alignments.push(debug().column());
    }
  }

  /**
   * Add a statement. If the statement is part of an expression (e.g.,
   * "(n = *cp) == 0"), we queue it as a post-statement. If the expression depth
   * is 0 (meaning, this is a top-level statement, we flush the post-statement
   * queue.
   */
  private void addStatement(Statement stmt) {
  	if(!isCollectStmts) return;
  	
    postStatements.add(stmt);
    postStatements.addAll(appendStatements);
    appendStatements.clear();
    if (expressionDepth == 0) {
      flushPostStatements();
    }
  }

	/** Append the post-statements accumulated to the current block. */
  private void flushPostStatements() {
    addAndFlushPostStatements(currentBlock);
  }

  /** Append the post-statements accumulated to all given blocks. This is necessary
   * to make sure effects appear along all branches. E.g., the side effects of an 
   * "if" test will appear at the beginning of both the "then" and "else" blocks. */
  private void addAndFlushPostStatements(BasicBlock first, BasicBlock... rest) {
    // TODO: What about prestatements (like ++i)?
    if (postStatements.isEmpty())
      return;

    debug().pln(
        "flushing expression statement effects (size=" + postStatements.size()
            + ") to block #" + first.getId()).flush();
    first.addStatements(postStatements);
    for (BasicBlock b : rest) {
      debug().pln(
          "flushing expression statement effects (size="
              + postStatements.size() + ") to block #" + b.getId()).flush();
      b.addStatements(postStatements);
    }
    postStatements.clear();
  }

  /** Dump all scopes. Useful as a hygienic measure against ill-nested scopes. */
  private void flushScopes() {
    scopes.clear();
  }

  /** Leave a scope. */
  private void popScope() {
    //exitScope();
    scopes.removeFirst();
  }

  /** Enter a scope bracketed by the given blocks. */
  private void pushScope(BasicBlock entry, BasicBlock exit) {
    Scope s = new Scope(entry, exit);
    scopes.addFirst(s);
  }

  /** Enter a case scope bracketed by the given blocks, guarded by the given expression. */
  private void pushScope(BasicBlock entry, BasicBlock exit, CExpression caseExpr) {
    Scope s = new Scope(entry, exit, caseExpr);
    scopes.addFirst(s);
  }
  
  /** SymbolTable enters a nested scope. */
  private void enterScope(GNode node) {
    symbolTable.enterScope(node);
  }
  
  /** SymbolTable exit a nested scope. */
  private void exitScope() {
    symbolTable.setScope(symbolTable.getCurrentScope().getParent());
  }

  /** Find the smallest enclosing non-case scope. Used to resolve continue
   * statements. */
  private BasicBlock getLoopEntry() {
    // TODO: will this work for more complex CFGs?
    for (Scope s : scopes) {
      if (s.getCaseExpr() == null) {
        return s.getEntry();
      }
    }
    return null;
  }

  /** Find the smallest enclosing case scope. Used to find the in-edge for 
   * case labels. */
  private BasicBlock getSwitchEntry() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getEntry();
      }
    }
    return null;
  }

  /** Find the exit block for the smallest enclosing scope. */
  private BasicBlock getBreakTarget() {
    return scopes.peek().getExit();
  }

  /** Add an outgoing edge to the given exit block iff the current block has
   * no existing successors. Used when the builder "falls through" the end of 
   * a block which may or may not have acquired an unconditional edge somewhere
   * deeper in the AST. E.g., if the last statement of a loop is a break, then
   * there shouldn't be a default edge back to the loop test.
   */
  private void closeCurrentBlock(BasicBlock exitBlock) {
    if (currentCfg.getSuccessors(currentBlock).isEmpty()) {
      currentCfg.addEdge(currentBlock, exitBlock);
    }
  }

  private void addCaseGuard(CaseGuard g) {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        s.addCaseGuard(g);
      }
    }
  }

  private List<CaseGuard> getCaseGuards() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getCaseGuards();
      }
    }
    return ImmutableList.of();
  }

  private CExpression getCaseExpression() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.getCaseExpr();
      }
    }
    return null;
  }

  private boolean hasDefault() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        return s.hasDefault();
      }
    }
    return true;
  }

  private void setHasDefault() {
    for (Scope s : scopes) {
      if (s.getCaseExpr() != null) {
        s.setHasDefault();
        return;
      }
    }
  }
  
  private void setCaseGuard(CaseGuard guard) {
    for(Scope s : scopes) {
      if(s.getCaseExpr() != null) {
        s.addCaseGuard(guard);
      }
    }
  }

  private CExpression recurseOnExpression(Node node) {
    expressionDepth++;
    CExpression e = (CExpression) dispatch(node);
    expressionDepth--;
    return e;
  }
  
  private Node defineReturnVarNode(String funcName, Node func) {
    String varName = Identifiers.uniquify(Identifiers.RETURN_VAR_PREFIX + '_' + funcName);
    Location loc = func.getLocation();
    Type type = lookupType(func);
    type = type.annotate().shape(new DynamicReference(varName,type));
    
    GNode varDeclareNode = GNode.create("SimpleDeclarator", varName);
    varDeclareNode.setLocation(loc);
    type.mark(varDeclareNode);
    cAnalyzer.processExpression(varDeclareNode);
    createAuxVarBinding(varDeclareNode, Identifiers.RETURN_VAR_PREFIX);
    
    GNode varNode = GNode.create("PrimaryIdentifier", varName);
    varNode.setLocation(loc);
    type.mark(varNode);
    //FIXME: process(varNode) sometimes attach root scope
    cAnalyzer.processExpression(varNode);
    
    return varNode; 
  }

  private Node defineStringVarNode(Node stringVar) {
  	String varName = Identifiers.uniquify(Identifiers.STRING_VAR_PREFIX);
  	Location loc = stringVar.getLocation();
  	Type type = lookupType(stringVar);
  	type = redefineArrayType(type);
    type = type.annotate().shape(new DynamicReference(varName, type));
  	
    GNode varDeclareNode = GNode.create("SimpleDeclarator", varName);
    varDeclareNode.setLocation(loc);
    type.mark(varDeclareNode);
    cAnalyzer.processExpression(varDeclareNode);
    createAuxVarBinding(varDeclareNode, Identifiers.STRING_VAR_PREFIX);
    
    GNode varNode = GNode.create("PrimaryIdentifier", varName);
    varNode.setLocation(loc);
    type.mark(varNode);
    cAnalyzer.processExpression(varNode);
    return varNode; 
  }
  
  private Type redefineArrayType(Type type) {
		Preconditions.checkArgument(type.resolve().isArray());
		ArrayT arrayType = type.resolve().toArray().copy();
		arrayType.setLength(arrayType.getLength() + 1);
		Reference shape = type.getShape();
		return arrayType.annotate().shape(shape);
	}

	private Type redefineStringType(Type type) {
		Preconditions.checkArgument(type.hasShape());
		Preconditions.checkArgument(type.getShape().isString());
		Preconditions.checkArgument(type.resolve().isArray());
		ArrayT arrayType = type.resolve().toArray().copy();
		arrayType.setLength(arrayType.getLength() + 1);
		
		Reference shape = type.getShape();
		String literal =  ((StringReference) shape).getLiteral();
		StringBuilder sb = new StringBuilder();
		if(literal != null) sb.append(literal);
		sb.append('\u0000');
		
		Reference newShape = new StringReference(sb.toString(), arrayType);
		return arrayType.annotate().shape(newShape);
	}

	private Type lookupType(Node node) {
    Type type = null;
    if(!node.hasProperty(CType.TYPE)) {
      type = symbolTable.lookupType(node.getString(0));
    } else {
      type = CType.getType(node);
    }
    if (type == null)
      throw new ExpressionFactoryException("Type not found: " + node);
    return type;
  }
  
  private Statement getValidMallocStmt(Node node, Node lhsNode, Node sizeNode) {
	  GNode funcNode = GNode.create("PrimaryIdentifier", ReservedFunction.FUN_VALID_MALLOC);
	  GNode argList = GNode.create("ExpressionList", lhsNode, sizeNode);
	  GNode validMallocNode = GNode.create("FunctionCall", funcNode, argList);
	  Location loc = node.getLocation();
	  funcNode.setLocation(loc);
	  validMallocNode.setLocation(loc);
	  cAnalyzer.processExpression(validMallocNode);
	  return Statement.assumeStmt(validMallocNode, expressionOf(validMallocNode));
	}

	private void memoryCheck(Node node) {
    if(!Preferences.isSet(Preferences.OPTION_MEMORY_CHECK)) return;
    
    GNode funcNode = GNode.create("PrimaryIdentifier", ReservedFunction.FUN_VALID);
    GNode addrNode = GNode.create("AddressExpression", node);
    GNode argList = GNode.create("ExpressionList", addrNode);
    GNode validNode = GNode.create("FunctionCall", funcNode, argList);
    Location loc = node.getLocation();
    funcNode.setLocation(loc);
    validNode.setLocation(loc);
    cAnalyzer.processExpression(validNode);
    Statement res = Statement.assertStmt(validNode, expressionOf(validNode));
    res.addPostLabel(ReservedFunction.FUN_VALID);
    addStatement(res);
  }
  
  /** Create a copy of <code>node</code>, return null if
   * node is null 
   */
  private GNode createCopy(GNode node) {
  	if(node == null) return node;
  	
  	GNode freshNode = GNode.create(node);
  	for(String label : node.properties()) { // copy properties
  		freshNode.setProperty(label, node.getProperty(label));
  	}
  	freshNode.setLocation(node.getLocation()); // copy location
  	return freshNode;
  }
  
  private CExpression processAssignment(GNode srcNode, Node lhsNode, String assignOperator, Node rhsNode) {
    if(rhsNode.hasName("StringConstant")) {
    	/* Initialize string into char array */
    	GNode initListNode = getInitListNodeForString(GNode.cast(rhsNode));
    	Type lhsType = CType.getType(lhsNode).resolve();
    	if(lhsType.isArray()) {
    		rhsNode = initListNode;
    	} else {
    		/* Get a fresh declared string_var node */
      	CExpression strConst = recurseOnExpression(rhsNode);
      	Node strVarNode = strConst.getSourceNode();
    		processCompoundAssign(srcNode, strVarNode, initListNode);
      	rhsNode = strVarNode;
    	}
    }
    
    if(rhsNode.hasName("InitializerList"))
    	return processCompoundAssign(srcNode, lhsNode, rhsNode);
    
    if(isMalloc.apply(rhsNode)) 
    	return processMallocAssign(srcNode, lhsNode, rhsNode);
    else
    	return processScalarAssign(srcNode, lhsNode, assignOperator, rhsNode);
  }
  
  private CExpression processMallocAssign(GNode srcNode, Node lhsNode, Node rhsNode) {
  	CExpression lhsExpr = recurseOnExpression(lhsNode);
  	CExpression rhsExpr = recurseOnExpression(rhsNode);
  	
  	Node rhsNodePrime = rhsExpr.getSourceNode();
  	Node sizeNode = rhsNodePrime.getNode(1).getNode(0);
  	CExpression sizeExpr = recurseOnExpression(sizeNode);
    
		Statement resultStmt = Statement.alloc(srcNode, lhsExpr, sizeExpr);
		Statement validMalloc = getValidMallocStmt(srcNode, lhsNode, sizeNode);
		
		addStatement(resultStmt);
		addStatement(validMalloc);
		return lhsExpr;
  }
  
  private CExpression processScalarAssign(GNode srcNode, Node lhsNode, String assignOperator, Node rhsNode) {
  	CExpression lhsExpr = recurseOnExpression(lhsNode);
  	CExpression rhsExpr = recurseOnExpression(rhsNode);
  	/* The assignment operator may be one of +=, -=, et al., in which case the
     * rhs is the whole statement, e.g., x += y becomes something like (assign x
     * (x += y)) instead of (assign x (x+y)), because replacing the operator
     * here would be a PITA. It's up to the expression visitor to turn that into
     * an addition.
     */
    if (!"=".equals(assignOperator)) rhsExpr = expressionOf(srcNode);
    
    Statement resultStmt = Statement.assign(srcNode, lhsExpr, rhsExpr);
    addStatement(resultStmt);
  	return lhsExpr;
  }
  
  private CExpression processCompoundAssign(GNode srcNode, Node lhsNode, Node rhsNode) {
  	CExpression lhsExpr = recurseOnExpression(lhsNode);
  	Type lhsType = CType.getType(lhsNode).resolve();
  	if(lhsType.isArray()) {
  		processArrayAssign(srcNode, lhsNode, rhsNode);
  	} else if(lhsType.isStruct()) {
  		processStructAssign(srcNode, lhsNode, rhsNode);
  	}
  	return lhsExpr;
  }
  
  private void processStructAssign(GNode srcNode, Node lhsNode, Node rhsNode) {
  	StructT structType = CType.getType(lhsNode).resolve().toStruct();
  	assert(structType.getMemberCount() == rhsNode.size());
  	Iterator<Object> itr = rhsNode.iterator();
  	for(VariableT member : structType.getMembers()) {
  		String field = member.getName();
  		GNode compSelect = GNode.create("DirectComponentSelection", lhsNode, field);
  		compSelect.setLocation(srcNode.getLocation());
  		cAnalyzer.processExpression(compSelect);
  		Node fieldInitializerListEntry = (Node) itr.next();
  		processAssignment(srcNode, compSelect, "=", fieldInitializerListEntry.getNode(1));
  	}
  }
  
  private void processArrayAssign(GNode srcNode, Node lhsNode, Node rhsNode) {
  	ArrayT arrayType = CType.getType(lhsNode).resolve().toArray();
  	List<CExpression> args = flattenInitializerList(arrayType, rhsNode);
  	GNode castArrayNode = castArrayNode(lhsNode);
  	int index = 0;
  	for(CExpression arg : args) {
  		GNode idxNode = GNode.create("IntegerConstant", String.valueOf(index++));
  		GNode currNode = GNode.create("AdditiveExpression", castArrayNode, "+", idxNode);
  		GNode lhsNodePrime = GNode.create("IndirectionExpression", currNode);
  		cAnalyzer.processExpression(lhsNodePrime);
  		CExpression currLhsExpr = recurseOnExpression(lhsNodePrime);
  		cAnalyzer.processExpression(arg.getSourceNode());
  		Statement assignStmt = Statement.assign(srcNode, currLhsExpr, arg);
  		addStatement(assignStmt);
  	}
  }
  
  private List<CExpression> flattenInitializerList(Type type, Node rhsNode) {
  	Preconditions.checkArgument(rhsNode.hasName("InitializerList"));
  	Preconditions.checkArgument(type.isArray());
  	ArrayT arrayType = type.toArray();
  	List<CExpression> rhsExprs = Lists.newArrayList();
  	for(Object entry : rhsNode) {
  		assert(entry instanceof Node);
  		Node entryNode = (Node) entry;
  		assert(entryNode.hasName("InitializerListEntry"));
  		Node valueNode = entryNode.getNode(1);
  		if(valueNode.hasName("InitializerList")) {
  			rhsExprs.addAll(flattenInitializerList(arrayType.getType(), valueNode));
  		} else {
  			rhsExprs.add(recurseOnExpression(valueNode));
  		}
  	}
  	if(!arrayType.hasLength()) return rhsExprs;
  	
  	long size = CType.getArraySize(arrayType);
  	if(size < rhsExprs.size()) return rhsExprs.subList(0, (int) size);
  	
  	Type cellType = CType.getCellType(arrayType);
  	while(size > rhsExprs.size()) {
  		Node defaultNode = null;
  		if(cellType.isNumber()) {
  			switch(cellType.toNumber().getKind()) {
				case CHAR:
					defaultNode = GNode.create("CharacterConstant", String.valueOf('\u0000'));
					break;
				case INT:
					defaultNode = GNode.create("IntegerConstant", String.valueOf(0));
					break;
				case LONG:
					defaultNode = GNode.create("LongConstant", String.valueOf(0));
					break;
				default:
					throw new IllegalArgumentException("Unknown default value for type " + cellType.getName());
  			}
  		}
  		CExpression defaultExpr = recurseOnExpression(defaultNode);
  		rhsExprs.add(defaultExpr);
  	}
  	return rhsExprs;
  }
  
  private GNode castArrayNode(Node lhsNode) {
  	Type baseType = CType.getCellType(CType.getType(lhsNode).resolve());
  	String baseTypeName = StringUtils.capitalizeFirstLetter(baseType.toString());
  	GNode typeNameNode = 
  			GNode.create("TypeName", 
  					GNode.create("SpecifierQualifierList", GNode.create(baseTypeName)), 
  					GNode.create("AbstractDeclarator", 
  							GNode.create("Pointer", GNode.create("TypeQualifierList"), null), null));
  	GNode castNode = 
  			GNode.create("CastExpression", typeNameNode, lhsNode);
  	castNode.setLocation(lhsNode.getLocation());
  	cAnalyzer.processExpression(castNode);
  	return castNode;
  }
  
  private void createAuxVarBinding(Node node, String label) {
  	String name = node.getString(0);
  	debug().pln(
  			"Looking up binding for variable: " + name + " in symbol table "
  					+ symbolTable);
  	
  	assert(!symbolTable.isDefined(name));
  	Type type = CType.getType(node);
  	IRVarInfo binding = VarInfoFactory.createVarInfoWithType(
  			CType.getScopeName(node), name, type);
  	binding.setProperty(Identifiers.HOARE_VAR, true);
  	binding.setDeclarationNode(node);
  	binding.setProperty(Identifiers.AUXLABEL, label);
  	symbolTable.define(name, binding);
  	debug().pln("Binding: " + binding).flush();
  	
  	CExpression resExpr = expressionOf(node);
  	Statement declareStmt = Statement.declare(node, resExpr);
  	addStatement(declareStmt);
  }

	private GNode getInitListNodeForString(GNode node) {
	  // pick the content to create a node for initialization
	  Location loc = node.getLocation();
	  Type newType = redefineStringType(lookupType(node));
	  Reference shape = newType.getShape();
	  assert(shape.isString());
	  String content = ((StringReference) shape).getLiteral();
	
	  xtc.util.Pair<Object> operands = null;
	  for(int i=0; i<content.length(); i++) {
	    char c = content.charAt(i);
	    // Here, we translate the single character to the char with ASCII code.
	    StringBuilder sb = new StringBuilder().append('\'').append(c).append('\'');
	    GNode charConst = GNode.create("CharacterConstant", sb.toString());
	    charConst.setLocation(loc);
	    GNode initEntry = GNode.create("InitializerListEntry", null, charConst);
	    initEntry.setLocation(node.getLocation());
	    if(i == 0)    operands = new xtc.util.Pair<Object>(initEntry);
	    else          operands = operands.append(new xtc.util.Pair<Object>(initEntry));
	  }
	  
	  GNode initListNode = GNode.createFromPair("InitializerList", operands);
	  cAnalyzer.processExpression(initListNode);
	  return initListNode;
	}

	@Override
  public Object unableToVisit(Node node) {
    IOUtils
        .debug()
        .p("Ignoring unexpected node type: ")
        .pln(node.getName())
        .flush();
    return node;
  }

  public CExpression visitAdditiveExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(2, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }
  
  public CExpression visitMultiplicativeExpression(GNode node) {
    /* recurse on operands to tease out any side-effecting expressions */
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(2, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public CExpression visitAddressExpression(GNode node) {
  	CExpression fstExpr = recurseOnExpression(node.getNode(0));
  	
    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    if(fstExpr.getSourceNode().hasName("PrimaryIdentifier")) {
    	String name = fstExpr.getSourceNode().getString(0);
    	IRVarInfo info = symbolTable.lookup(name);
    	info.setProperty(Identifiers.HOARE_VAR, false);
    }
    return expressionOf(freshNode);
  }

  public CExpression visitAssignmentExpression(GNode node) {
    Node lhsNode = node.getNode(0);
    String assignOperator = node.getString(1);
    Node rhsNode = node.getNode(2);
    
    if( debugEnabled() ) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(lhsNode).p(
        " " + assignOperator + " ");
      
      IOUtils.debugC(rhsNode).pln().flush();
    }
    
    return processAssignment(node, lhsNode, assignOperator, rhsNode);
  }

	public CExpression visitBitwiseAndExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(1, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }
	
	public CExpression visitBitwiseNegationExpression(GNode node) {
    CExpression srcExpr = recurseOnExpression(node.getNode(0));
    GNode freshNode = createCopy(node);
    freshNode.set(0, srcExpr.getSourceNode());
    return expressionOf(freshNode);
  }
  
  public CExpression visitBitwiseOrExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(1, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }
  
  public CExpression visitBitwiseXorExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(1, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public void visitBreakStatement(GNode node) {
    debug().loc(node).p(' ').indent().pln("break").flush();
    /* Add a skip as an anchor for the source line. */
    currentBlock.addStatement(Statement.skip(node));
    currentCfg.addEdge(currentBlock, getBreakTarget());

    /* This block will be a repository for dead code! 
     * TODO: Detect and eliminate vestigial blocks?
     */
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  }

  public void visitCaseLabel(GNode node) {
    Node val = node.getNode(0);

    debug()
        .loc(node)
        .p(' ')
        .decr()
        .indent()
        .p("case ");
    debugC(val)
        .pln(":")
        .incr()
        .flush();

    CExpression valExpr = recurseOnExpression(val);
    CaseGuard guard = new CaseGuard(getCaseExpression(), valExpr);
    currentCfg.addEdge(getSwitchEntry(), guard, currentBlock);
    addCaseGuard(guard);
  }

  public CExpression visitCastExpression(GNode node) {
    if(isMalloc.apply(node.getNode(1)))  return recurseOnExpression(node.getNode(1));
    
    CExpression typeExpr = recurseOnExpression(node.getNode(0));
    CExpression opExpr = recurseOnExpression(node.getNode(1));
//    addStatement(Statement.cast(node, typeExpr, opExpr));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, typeExpr.getSourceNode());
    freshNode.set(1, opExpr.getSourceNode());
    return expressionOf(freshNode); // (int *)p;
  }

  public CExpression visitCharacterConstant(GNode node) {
    return expressionOf(node);
  }
  
  public CExpression visitConditionalExpression(GNode node) {
  	CExpression condExpr = recurseOnExpression(node.getNode(0));
  	CExpression trueExpr = recurseOnExpression(node.getNode(1));
  	CExpression falseExpr = recurseOnExpression(node.getNode(2));
  	
  	GNode freshNode = createCopy(node);
  	freshNode.set(0, condExpr.getSourceNode());
  	freshNode.set(1, trueExpr.getSourceNode());
  	freshNode.set(2, falseExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public void visitCommaExpression(GNode node) {
    for(Object o : node) {
      dispatch((Node) o);
    }
  }
  
  public void visitCompoundStatement(GNode node) {
  	if(symbolTable.hasScope(node)) {
    	enterScope(node);
      for (Object o : node) {
        dispatch((Node) o);
      }
      exitScope();
    } else {
      for (Object o : node) {
        dispatch((Node) o);
      }
    }
  }

  public void visitContinueStatement(GNode node) {
    debug().loc(node).indent().pln("continue").flush();
    /* Add a skip as an anchor for the source line. */
    currentBlock.addStatement(Statement.skip(node));
    currentCfg.addEdge(currentBlock, getLoopEntry());

    /*
     * This block will be a repository for dead code! 
     * TODO: Detect and eliminate vestigial blocks?
     */
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  }

  public void visitDeclaration(GNode node) {
    Node type = node.getNode(1);
    
    Node declarations = node.getNode(2);
    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(type).p(' ');
      IOUtils.debugC(declarations).pln().flush();
    }
    
    if(type != null) {
    	for(Object o : type) {
    		dispatch((Node) o); flushPostStatements();
    	}
    }
    
    if (declarations != null) {
    	for (Object o : declarations) {
    		dispatch((Node) o); flushPostStatements();
      }
    }
  }
  
  public void visitEnumerationTypeDefinition(GNode node) {
  	GNode enumList = node.getGeneric(2);
  	if(enumList != null)  {
  		List<CExpression> enumExprList = visitEnumeratorList(enumList);
  		addStatement(Statement.declareEnum(node, enumExprList));
  	}
  }
  
  public List<CExpression> visitEnumeratorList(GNode node) {
  	List<CExpression> enumList = Lists.newArrayListWithCapacity(node.size());
    for (Object elem : node) {
      enumList.add(recurseOnExpression((Node) elem));
    }
    return enumList;
  }
  
  public CExpression visitEnumerator(GNode node) {
  	String name = node.getString(0);
    debug().pln(
        "Looking up binding for variable: " + name + " in symbol table "
            + symbolTable);
    assert (symbolTable.isDefined(name));
    assert (symbolTable.getCurrentScope().equals(symbolTable.lookupScope(name)));
    
    IRVarInfo varInfo = symbolTable.lookup(name);
    varInfo.setDeclarationNode(node);
    
    return expressionOf(node);
  }

  public void visitDefaultLabel(GNode node) {
    IOUtils
        .debug()
        .loc(node)
        .p(' ')
        .decr()
        .indent()
        .pln("default:")
        .incr()
        .flush();

    IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
    currentCfg.addEdge(getSwitchEntry(), guard, currentBlock);
    setHasDefault();
  }

  public CExpression visitEqualityExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
  	GNode freshNode = createCopy(node);
  	freshNode.set(0, lhsExpr.getSourceNode());
  	freshNode.set(2, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public List<CExpression> visitExpressionList(GNode node) {
    List<CExpression> subExprList = Lists.newArrayListWithCapacity(node.size());
    for (Object elem : node) {
      CExpression subExpr = recurseOnExpression((Node) elem);
      subExprList.add(subExpr);
    }
    return subExprList;
  }

  public void visitExpressionStatement(GNode node) {
    dispatch(node.getNode(0));
    flushPostStatements();
  }

  /* Do-nothing implementation to make errors from header files go away. */
  public CExpression visitFunctionDeclarator(GNode node) {
    // TODO: Something
    return expressionOf(node);
  }
  
  public CExpression visitArrayDeclarator(GNode node) {
    Node declareNode = node.getNode(0);
    return recurseOnExpression(declareNode);
  }
  
  @SuppressWarnings("unchecked")
  public CExpression visitFunctionCall(GNode node) {
    Preconditions.checkArgument(node.getNode(0).hasName("PrimaryIdentifier"));
    Node funNode = node.getNode(0);
    Node argList = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent().p(funNode).p('(');
      if(argList != null) {
        Iterator<Object> argIter = argList.iterator();
        while (argIter.hasNext()) {
          Node arg = (Node) argIter.next();
          debug().p(arg);
          if (argIter.hasNext()) {
            debug().p(',');
          }
        }
      }
      debug().pln(')').flush();
    }
    
    String funcName = funNode.getString(0);
    
    /*
     *  For special functions like "malloc" and "free", we treat them differently
     *  1) malloc: just return the expression, do not add statement wait for the 
     *  visitAssignmentExpression to do that, since in malloc(x), we just know 
     *  the size "x", but the regionName cannot be known until return to the assign
     *  statement as y = malloc(x). Then we could add alloc(y, x)) by calling the 
     *  internal function alloc(...).
     *  2) free: could add statement directly as free(x)
     *  3) for others non-reserved functions, add functionCall statement, we'll 
     *  do the real calling as pick the cfg of the function in the RunProcessor
     */
  	
    if(ReservedFunction.FUN_FORALL.equals(funcName)
    		|| ReservedFunction.FUN_EXISTS.equals(funcName)
    		|| ReservedFunction.MALLOC.equals(funcName) 
    		|| ReservedFunction.FUN_IMPLIES.equals(funcName)
    		|| ReservedFunction.FUN_VALID.equals(funcName)
    		|| ReservedFunction.FUN_VALID_MALLOC.equals(funcName)
    		|| ReservedFunction.FUN_VALID_FREE.equals(funcName)) {
    	return expressionOf(node);
    }
    
    List<CExpression> argExprs = (List<CExpression>) dispatch(argList);
  		
		if(ReservedFunction.FREE.equals(funcName)) {
      GNode funcNode = GNode.create("PrimaryIdentifier", ReservedFunction.FUN_VALID_FREE);
      GNode validFreeNode = GNode.create("FunctionCall", funcNode, argList);
      Location loc = node.getLocation();
      funcNode.setLocation(loc);
      validFreeNode.setLocation(loc);
      cAnalyzer.processExpression(validFreeNode);
      addStatement(Statement.assertStmt(validFreeNode, expressionOf(validFreeNode)));
      addStatement(Statement.free(node, argExprs.get(0)));
      return expressionOf(node);
    }
		
		if(ReservedFunction.EXIT.equals(funcName)) {
    	addStatement(Statement.returnStmt(node, argExprs.get(0)));
    	currentCfg.addEdge(currentBlock, currentCfg.getExit());
    	return expressionOf(node);
    }
		
		if(ReservedFunction.ANNO_ASSERT.equals(funcName)) {
			if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
				addStatement(Statement.assertStmt(node, argExprs.get(0)));
			} else {
				CExpression funExpr = expressionOf(funNode);
	  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			}
			return expressionOf(node);
    } 

		if(ReservedFunction.ANNO_ASSUME.equals(funcName)) {
			if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
				addStatement(Statement.assumeStmt(node, argExprs.get(0)));
			} else {
				CExpression funExpr = expressionOf(funNode);
	  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			}
			return expressionOf(node);
    } 

		if(ReservedFunction.ANNO_INVARIANT.equals(funcName)) {
			if(Preferences.isSet(Preferences.OPTION_INLINE_ANNOTATION)) {
				addStatement(Statement.assumeStmt(node, argExprs.get(0)));
				addStatement(Statement.assertStmt(node, argExprs.get(0)));
			} else {
				CExpression funExpr = expressionOf(funNode);
	  		addStatement(Statement.functionCall(node, funExpr, argExprs));
			}
			return expressionOf(node);
    }

  	/*
    // [chris 1/8/2010] FIXME: avoid a lookup on the function name, since it
    // will probably return null
    if( funNode.hasName("PrimaryIdentifier") ) {
      funExpr = CExpression.create(funNode,symbolTable.getCurrentScope());
    } else {
      funExpr = recurseOnExpression(funNode);
    }*/
		
    if(lookupType(node).isVoid()) { // void return type of function
    	
  		/* Isolate function call into a fresh block */
  		
      BasicBlock funcBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
      currentCfg.addEdge(currentBlock, funcBlock);
      flushPostStatements(); // Add the statements to the current block
      
      currentBlock = funcBlock;
      
      CExpression funExpr = expressionOf(funNode);
      Statement stmt = Statement.functionCall(node, funExpr, argExprs);
      stmt.setProperty(Identifiers.STMTFUNC, true);
      stmt.setProperty(Identifiers.FUNCNAME, funcName);
      
      if(argExprs != null)	stmt.setProperty(Identifiers.ARGUMENTS, argExprs);
      
      addStatement(stmt);
      
      BasicBlock freshBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
      currentCfg.addEdge(currentBlock, freshBlock);
      flushPostStatements(); // Add the statements to the current block
      currentBlock = freshBlock;
      
      return expressionOf(node);
    }
    
  	Node returnNode = defineReturnVarNode(funcName, node);
  	
		/* Isolate function call into a fresh block */
		
    BasicBlock funcBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    currentCfg.addEdge(currentBlock, funcBlock);
    flushPostStatements(); // Add the statements to the current block
    
    currentBlock = funcBlock;
    
    GNode assignNode = GNode.create("AssignmentExpression", returnNode, "=", node);
    cAnalyzer.processExpression(assignNode);
    assignNode.setLocation(node.getLocation());      
    CExpression returnExpr = recurseOnExpression(returnNode);
    CExpression funCallExpr = expressionOf(node);
    Statement stmt = Statement.assign(assignNode, returnExpr, funCallExpr);
    stmt.setProperty(Identifiers.STMTFUNCASSIGN, true);
    stmt.setProperty(Identifiers.FUNCNAME, funcName);
    
    if(argExprs != null)	stmt.setProperty(Identifiers.ARGUMENTS, argExprs);
  	
    addStatement(stmt);
  	
    BasicBlock freshBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    currentCfg.addEdge(currentBlock, freshBlock);
    flushPostStatements(); // Add the statements to the current block
    currentBlock = freshBlock;
    
  	return returnExpr;
  	
  }

  public void visitDoStatement(GNode node) {
    Node test = node.getNode(1);
    Node body = node.getNode(0);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" while(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }
    
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), 
        symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    
    pushScope(entryBlock, exitBlock);
    
    currentBlock = entryBlock;
    
    CExpression testExpr = recurseOnExpression(test);
    
    /* Add the statements to the current block */
    flushPostStatements();

    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    currentCfg.addEdge(currentBlock, ifBranch, bodyBlock);
    currentCfg.addEdge(currentBlock, elseBranch, exitBlock);
    
    currentBlock = bodyBlock;
    dispatch(body);
    
    currentCfg.addEdge(currentBlock, entryBlock);
    
    closeCurrentBlock(entryBlock);  // close the loop
    currentBlock = exitBlock;  // exit the loop
    popScope();

    if( debugEnabled() ) {
      popAlign();
      debug().decr().flush();
    }
  }
  
  public void visitFunctionDefinition(GNode node) {
    /* Node is: FunctionDefinition(type modifiers, type signature (including
     * id), locals, body)
  	 */
  	
  	/* Push global info */
  	BasicBlock preCurrentBlock = currentBlock;
  	List<Statement> prePostStatements = postStatements;
  	List<Statement> preAppendStatements = appendStatements;
  	int preExpressionDepth = expressionDepth;
  	ControlFlowGraph preCfg = currentCfg;
  	
  	/* Analyze current function definition */
    final GNode returnType = node.getGeneric(1);
    final GNode declarator = node.getGeneric(2);
    final GNode identifier = CAnalyzer.getDeclaredId(declarator);
    final String functionName = identifier.getString(0);
    
    /* FunctionDefiniion node has 'scope' property, here enter the scope
     * directly, ignore the following compoundStatement; it means no need
     * to enter scope there, set 'CompoStmtAsScope' as 'false'
     */
    enterScope(node);
    
    currentCfg = new ControlFlowGraph(node, functionName, symbolTable
        .getCurrentScope());
    currentBlock = currentCfg.getEntry();
    addStatement(Statement.scopeEnt(node));
    
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    
    flushScopes();
    pushScope(currentBlock, currentCfg.getExit());
    
    currentCfg.addEdge(currentCfg.getEntry(), currentBlock);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      IOUtils.debugC(returnType).p(' ');
      IOUtils.debugC(declarator).pln(" {").incr().flush();
    }

    postStatements = Lists.newLinkedList();
    appendStatements = Lists.newArrayList();
    expressionDepth = 0;

    GNode parameters = CAnalyzer.getFunctionDeclarator(declarator).getGeneric(1);
    if( parameters != null ) {
      parameters = parameters.getGeneric(0);
    }
    
    cAnalyzer.processExpression(parameters);
    if (parameters != null) {
      for (Object o : parameters) {
        assert (o instanceof Node);
        assert (((Node) o).hasName("ParameterDeclaration"));
        // Drill down to the actual declaration
        dispatch(((Node) o).getNode(1));
      }
    }

    /* recurse on the function body */
    final GNode body = node.getGeneric(4);
    dispatch(body);
    
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
    
    currentBlock = currentCfg.getExit();
    
    addStatement(Statement.scopeExit(symbolTable.getCurrentScope().getName()));
    
    cfgs.put(node, currentCfg);

    if( debugEnabled() ) {
      popAlign();
      debug().decr().pln("} // end function").flush().reset();
      currentCfg.format(debug());
    }
    exitScope();
    
    /* Pop global info */
    currentCfg = preCfg;
    currentBlock = preCurrentBlock;
    postStatements = prePostStatements;
    appendStatements = preAppendStatements;
    expressionDepth = preExpressionDepth;
  }

  public void visitGotoStatement(GNode node) {
    Node labelNode = node.getNode(1);
    Preconditions.checkArgument(labelNode.hasName("PrimaryIdentifier"));
    recurseOnExpression(labelNode);
    String labelName = labelNode.getString(0);
    Pair<String, ControlFlowGraph> key = Pair.of(labelName, currentCfg);
    if(!labeledBlocks.containsKey(key)) {
    	BasicBlock labelStmt = currentCfg.newLabelBlock(
    			symbolTable.getCurrentScope());
    	labelStmt.addPreLabel(labelName);
      labeledBlocks.put(key, labelStmt);
    }
    BasicBlock labelBlock = labeledBlocks.get(key);
    currentCfg.addEdge(currentBlock, labelBlock);
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  }
  
  public void visitIfElseStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);
    Node elsePart = node.getNode(2);

    if( debugEnabled() ) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().indent().p("if(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }

    xtc.util.SymbolTable.Scope currScope = symbolTable.getCurrentScope();
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), currScope);
    BasicBlock ifBlock = currentCfg.newBlock(currScope);
    BasicBlock elseBlock = currentCfg.newBlock(currScope);
    BasicBlock exitBlock = currentCfg.newBlock(currScope);

    currentCfg.addEdge(currentBlock, entryBlock);
    
    currentBlock = entryBlock;
    
    CExpression testExpr = recurseOnExpression(test);

    /* Add the location of the conditional test to the current block */
    entryBlock.addLocation(testExpr.getLocation());
    /* Add the statements to the current block */
    addAndFlushPostStatements(currentBlock);
    
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    currentCfg.addEdge(currentBlock, ifBranch, ifBlock);
    currentCfg.addEdge(currentBlock, elseBranch, elseBlock);
    
    currentBlock = ifBlock;
    dispatch(ifPart);
    closeCurrentBlock(exitBlock);

    if( debugEnabled() ) {
      peekAlign();
      debug().p(' ').decr().indent().pln("else").incr().flush();
    }
    
    currentBlock = elseBlock;
    dispatch(elsePart);
    closeCurrentBlock(exitBlock);
    currentBlock = exitBlock;

    if( debugEnabled() ) {
    popAlign();
    debug().decr().pln("}").flush();
    }
  }

  public void visitIfStatement(GNode node) {
    Node test = node.getNode(0);
    Node ifPart = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent().p("if(");
      debugC(test).pln(")").incr().flush();
    }
    
    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock ifBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    currentCfg.addEdge(currentBlock, entryBlock);
    
    currentBlock = entryBlock;
    
    CExpression testExpr = recurseOnExpression(test);

    /* Add the location of the conditional test to the current block */
    entryBlock.addLocation(testExpr.getLocation());
    /* Add the statements to the current block */
    addAndFlushPostStatements(currentBlock);
    
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    currentCfg.addEdge(currentBlock, ifBranch, ifBlock);
    currentCfg.addEdge(currentBlock, elseBranch, exitBlock);

    currentBlock = ifBlock;
    dispatch(ifPart);
    closeCurrentBlock(exitBlock);
    currentBlock = exitBlock;

    debug().decr().flush();
  }

  CExpression expressionOf(Node node) {
  	return symbolTable.hasScope(node) ? 
  			CExpression.create(node, symbolTable.getScope(node)) :
  				CExpression.create(node, symbolTable.getCurrentScope());
  }

  public CExpression visitIndirectionExpression(GNode node) {
  	memoryCheck(node);
    CExpression fstExpr = recurseOnExpression(node.getNode(0));
    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public void visitInitializedDeclarator(GNode node) {
    Node varNode = node.getNode(1);
    CExpression varExpr = recurseOnExpression(varNode);
    Object val = node.get(4);
    if(val == null) return;
    /* If there is an initializer, add as an assignment statement */
    processAssignment(node, varExpr.getSourceNode(), "=", (Node)val);
  }

  public List<CExpression> visitInitializerList(GNode node) {
    List<CExpression> subExprList = Lists.newArrayListWithCapacity(node.size());
    for (Object elem : node) {
      CExpression subExpr = recurseOnExpression((Node) elem);
      subExprList.add(subExpr);
    }
    return subExprList;
  }

  public CExpression visitInitializerListEntry(GNode node) {
    return expressionOf(node.getNode(1));
  }
  
  public CExpression visitIntegerConstant(GNode node) {
    return expressionOf(node);
  }
  
  public CExpression visitFloatingConstant(GNode node) {
    return expressionOf(node);
  }

  public void visitLabeledStatement(GNode node) {
    Node label = node.getNode(0);
    Node stmt = node.getNode(1);
    
    BasicBlock labelStmt;

    if(label.hasName("NamedLabel")) {
      String labelName = label.getString(0);
      Pair<String, ControlFlowGraph> key = Pair.of(labelName, currentCfg);
      if(labeledBlocks.containsKey(key)) {
      	labelStmt = labeledBlocks.get(key);
      	labelStmt.addLocation(IRLocations.ofLocation(node.getLocation()));
      } else {
      	labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
        		symbolTable.getCurrentScope());
      	labelStmt.addPreLabel(labelName);
        labeledBlocks.put(key, labelStmt);
      }
      currentCfg.addEdge(currentBlock, labelStmt);
    } else if(label.hasName("CaseLabel")) {
      CExpression testExpr = getCaseExpression();
      CExpression caseLabel = recurseOnExpression(label.getNode(0));
      CaseGuard caseBranch = new CaseGuard(testExpr, caseLabel);
      setCaseGuard(caseBranch);
      labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
      		symbolTable.getCurrentScope());
      currentCfg.addEdge(currentBlock, caseBranch, labelStmt);
    } else if(label.hasName("DefaultLabel")) {
      setHasDefault();
      IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());
      labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
      		symbolTable.getCurrentScope());
      currentCfg.addEdge(currentBlock, guard, labelStmt);
    } else {
    	labelStmt = currentCfg.newLabelBlock(node.getLocation(), 
      		symbolTable.getCurrentScope());
    }
    
    currentBlock = labelStmt;
    dispatch(stmt);
  }

  public CExpression visitLogicalAndExpression(GNode node) {
    /* Deal with side-effects */
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(1, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  /* NEWADD: visitLogicalOrExpression */
  public CExpression visitLogicalOrExpression(GNode node) {
    /* Deal with side-effects */
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(1));

    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(1, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public CExpression visitLogicalNegationExpression(GNode node) {
    CExpression fstExpr = recurseOnExpression(node.getNode(0));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public CExpression visitSizeofExpression(GNode node) {
    CExpression fstExpr = recurseOnExpression(node.getNode(0));

    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public CExpression visitTypeName(GNode node) {
    CExpression fstExpr = recurseOnExpression(node.getNode(0));

    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public CExpression visitSpecifierQualifierList(GNode node) {
    return expressionOf(node);
  }

  public CExpression visitDirectComponentSelection(GNode node) {
    memoryCheck(node);
    CExpression fstExpr = recurseOnExpression(node.getNode(0));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public CExpression visitIndirectComponentSelection(GNode node) {
  	memoryCheck(node);
    CExpression fstExpr = recurseOnExpression(node.getNode(0));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }
  
  public CExpression visitPostdecrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" - 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");    
    GNode decNode = GNode.create("AdditiveExpression", opNode, "-", oneNode);
    GNode assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", decNode);
    oneNode.setLocation(loc);
    decNode.setLocation(loc);
    assignNode.setLocation(loc);
    cAnalyzer.processExpression(assignNode);
    Statement stmt = Statement.assign(assignNode, opExpr, CExpression.create(decNode, opExpr.getScope()));
    if(expressionDepth == 0)       addStatement(stmt);
    else                           appendStatements.add(stmt);

    return opExpr; // return the *prior value* of the operand
  }
  
  public CExpression visitPostincrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" + 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");    
    GNode incNode = GNode.create("AdditiveExpression", opNode, "+", oneNode);
    GNode assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", incNode);
    oneNode.setLocation(loc);
    incNode.setLocation(loc);
    assignNode.setLocation(loc);
    cAnalyzer.processExpression(assignNode);
    Statement stmt = Statement.assign(assignNode, opExpr, CExpression.
        create(incNode, opExpr.getScope()));
    if(expressionDepth == 0)       addStatement(stmt);
    else                           appendStatements.add(stmt);

    return opExpr; // return the *prior value* of the operand
  }

  public CExpression visitPredecrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" - 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");    
    GNode decNode = GNode.create("AdditiveExpression", opNode, "-", oneNode);
    GNode assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", decNode);
    oneNode.setLocation(loc);
    decNode.setLocation(loc);
    assignNode.setLocation(loc);
    cAnalyzer.processExpression(assignNode);  
    addStatement(Statement.assign(assignNode, opExpr, CExpression
        .create(decNode, opExpr.getScope())));

    return opExpr; // return the *prior value* of the operand
  }  
  
  public CExpression visitPreincrementExpression(GNode node) {
    Node opNode = node.getNode(0);
    Location loc = node.getLocation();

    if (debugEnabled()) {
      debug().loc(node).p(' ').indent();
      IOUtils.debugC(opNode).p(" := ");
      IOUtils.debugC(opNode).p(" + 1").pln().flush();
    }

    CExpression opExpr = recurseOnExpression(opNode);
    GNode oneNode = GNode.create("IntegerConstant", "1");
    GNode incNode = GNode.create("AdditiveExpression", opNode, "+", oneNode);
    GNode assignNode = GNode.create("AssignmentExpression", opExpr.getSourceNode(), "=", incNode);
    oneNode.setLocation(loc);
    incNode.setLocation(loc);
    assignNode.setLocation(loc);
    cAnalyzer.processExpression(assignNode);
    addStatement(Statement.assign(node, opExpr, CExpression
        .create(incNode, opExpr.getScope())));

    return opExpr; // return the *prior value* of the operand
  } 
  
  public CExpression visitPointerDeclarator(GNode node) {
    return recurseOnExpression(node.getNode(1));
  }

  public CExpression visitPrimaryIdentifier(GNode node) {
    return expressionOf(node);
  }

  public CExpression visitSimpleDeclarator(GNode node) {
    String name = node.getString(0);
    debug().pln(
        "Looking up binding for variable: " + name + " in symbol table "
            + symbolTable);
    assert (symbolTable.isDefined(name));
    assert (symbolTable.getCurrentScope().equals(symbolTable.lookupScope(name)));
    
    /* attach type and scope properties to node */
    cAnalyzer.processExpression(node);
    IRVarInfo varInfo = symbolTable.lookup(name);
    varInfo.setDeclarationNode(node);
    
    Type type = varInfo.getXtcType();
    
    /* Ignore typedef symbol */
    if(type.isAlias() && type.toAlias().getName().equals(name))
    	return expressionOf(node);
    
    // FIXME: array, struct and union type variables are also Hoare variable
    if(!(type.resolve().isArray() || type.resolve().isStruct() || type.resolve().isUnion())) {
    	varInfo.setProperty(Identifiers.HOARE_VAR, true);
    } else {
    	varInfo.setProperty(Identifiers.HOARE_VAR, false);
    }
    
    CExpression resExpr = expressionOf(node);
    Statement declareStmt = Statement.declare(node, resExpr);
    addStatement(declareStmt);
    
    GNode primaryId = GNode.create("PrimaryIdentifier", name);
    primaryId.setLocation(node.getLocation());
    for(String label : node.properties()) {
    	primaryId.setProperty(label, node.getProperty(label));
    }
    return expressionOf(primaryId);
  }

  public CExpression visitRelationalExpression(GNode node) {
    CExpression lhsExpr = recurseOnExpression(node.getNode(0));
    CExpression rhsExpr = recurseOnExpression(node.getNode(2));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, lhsExpr.getSourceNode());
    freshNode.set(2, rhsExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public void visitReturnStatement(GNode node) {
    if( debugEnabled() ) {
      IOUtils
        .debug()
        .loc(node)
        .p(' ')
        .indent()
        .p("return ");
      IOUtils.debugC(node.getNode(0))
        .pln()
        .flush();
    }
    
    if(node.getNode(0) != null) {
      CExpression val = recurseOnExpression(node.getNode(0));

      /*
       * NOTE: there may be reachable statements after a return statement in the
       * CFG. For example, "return i++" will be dismantled to "return i; i++".
       */
      addStatement(Statement.returnStmt(node, val));
    } else {
    	addStatement(Statement.returnStmt(node));
    }
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
  }
  
  public CExpression visitStringConstant(GNode node) {
    /* Newly-defined string variable node */
    Node stringVarNode = defineStringVarNode(node);
    CExpression stringVarExpr = recurseOnExpression(stringVarNode);
    return stringVarExpr;
  }

  public void visitSwitchStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    debug().loc(node).p(' ');
    pushAlign();
    debug()
        .indent()
        .p("switch(");
    debugC(test)
        .pln(")")
        .incr()
        .incr()
        .flush();

    CExpression testExpr = recurseOnExpression(test);

    // TODO: handle side effects in test expression
    // Create side-effect block and duplicate for every case?

    BasicBlock entryBlock = currentCfg.newSwitchBlock(node.getLocation(), 
            symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    pushScope(entryBlock, exitBlock, testExpr);
    currentCfg.addEdge(currentBlock, entryBlock);
    currentBlock = entryBlock;
    currentCfg.addEdge(currentBlock, bodyBlock);

    for(Object o : body) {
      if(o != null) {
      	if(!(o instanceof GNode)) {
      		if(o instanceof LineMarker) {
      			o = ((LineMarker) o).getNode();
      		} else {
      			throw new ExpressionFactoryException("What hell is " + o + "?");
      		}
      	}
      	Node node_o = (Node) o;
        if(node_o.hasName("LabeledStatement")) {
          currentBlock = bodyBlock;
          dispatch(node_o);
          if(hasDefault())  // FIXME: how about add break in default case
            closeCurrentBlock(exitBlock);          
        } else if(node_o.hasName("BreakStatement")) {
          dispatch(node_o);
          closeCurrentBlock(exitBlock);
        } else {
          dispatch(node_o);
        }
      }
    }

    currentBlock = exitBlock;

    if (!hasDefault()) {
      IRBooleanExpression guard = new DefaultCaseGuard(node, getCaseGuards());

      currentCfg.addEdge(bodyBlock, guard, exitBlock);
    }

    popScope();
    popAlign();
    debug().decr().flush();
  }

  public CExpression visitSubscriptExpression(GNode node) {
  	memoryCheck(node);
    CExpression baseExpr = recurseOnExpression(node.getNode(0));
    CExpression idxExpr = recurseOnExpression(node.getNode(1));
    GNode freshNode = createCopy(node);
    freshNode.set(0, baseExpr.getSourceNode());
    freshNode.set(1, idxExpr.getSourceNode());
    return expressionOf(freshNode);
  }
  
  public CExpression visitShiftExpression(GNode node) {
    return expressionOf(node);
  }

  /** Visit the specified translation unit. */
  public Map<Node, ? super ControlFlowGraph> visitTranslationUnit(GNode n) {
    cfgs.clear();
    
    /* build global cfg for global statements */
    currentCfg = new ControlFlowGraph(n, Identifiers.GLOBAL_CFG, symbolTable
        .rootScope());
    
    if (debugEnabled()) {
      debug().loc(n).p(' ');
      pushAlign();
      debug().p(" Global CFG (");
      IOUtils.debug().pln(")").incr().flush();
    }
    
    postStatements = Lists.newLinkedList();
    appendStatements = Lists.newArrayList();
    expressionDepth = 0;
    
    currentBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    currentCfg.addEdge(currentCfg.getEntry(), currentBlock);
    
    for (Object o : n) {
      dispatch((Node) o);
    }
    
    flushPostStatements();
    currentCfg.addEdge(currentBlock, currentCfg.getExit());
    
    cfgs.put(n, currentCfg);
    
    return cfgs;
  }

  public CExpression visitUnaryMinusExpression(GNode node) {
    CExpression fstExpr = recurseOnExpression(node.getNode(0));
    
    GNode freshNode = createCopy(node);
    freshNode.set(0, fstExpr.getSourceNode());
    return expressionOf(freshNode);
  }

  public void visitWhileStatement(GNode node) {
    Node test = node.getNode(0);
    Node body = node.getNode(1);

    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" while(");
      IOUtils.debugC(test).pln(")").incr().flush();
    }
    
    BasicBlock initBlock = currentCfg.newLoopInitBlock(symbolTable.getCurrentScope());
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getScope(body));
    BasicBlock loopExitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());

    pushScope(initBlock, loopExitBlock);
    
    currentCfg.addEdge(currentBlock, initBlock);
    
  	currentBlock = initBlock;
    CExpression testExpr = recurseOnExpression(test);
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    currentCfg.addEdge(currentBlock, entryBlock);
    
    currentBlock = entryBlock;
    flushPostStatements(); // Add the statements to the current block
    
    currentCfg.addEdge(currentBlock, ifBranch, bodyBlock);
    currentCfg.addEdge(currentBlock, elseBranch, loopExitBlock);
    
    currentBlock = bodyBlock;
    dispatch(body);
    
    currentCfg.addEdge(loopExitBlock, exitBlock);
    
    closeCurrentBlock(entryBlock); // close the loop
    currentBlock = exitBlock;
    popScope();
    
    if( debugEnabled() ) {
      popAlign();
      debug().decr().flush();
    }
  }
  
  public void visitForStatement(GNode node) {
    Node init = node.getNode(0);
    Node test = node.getNode(1);
    Node incr = node.getNode(2);
    Node body = node.getNode(3);
    
    if (debugEnabled()) {
      debug().loc(node).p(' ');
      pushAlign();
      debug().p(" for(");
      IOUtils.debugC(init).p("; ");
      IOUtils.debugC(test).p("; ");
      IOUtils.debugC(incr).pln(")").incr().flush();
    }
    
    /* ForStatement node has 'scope' property, here enter the scope directly,
     * ignore the following compoundStatement; it means no need to enter scope
     * there, set 'CompoStmtAsScope' as 'false'
     */
    enterScope(node);
    
    BasicBlock initBlock = currentCfg.newLoopInitBlock(symbolTable.getCurrentScope());
    BasicBlock entryBlock = currentCfg.newLoopBlock(node.getLocation(), 
        symbolTable.getCurrentScope());
    BasicBlock bodyBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock incrBlock = currentCfg.newBlock(symbolTable.getCurrentScope());
    BasicBlock loopExitBlock = currentCfg.newLoopExitBlock(symbolTable.getCurrentScope());
    BasicBlock exitBlock = currentCfg.newBlock(symbolTable.getCurrentScope());

    pushScope(initBlock, loopExitBlock);
  	
    currentCfg.addEdge(currentBlock, initBlock);
  	
    currentBlock = initBlock;   
    dispatch(init);
    
    currentCfg.addEdge(currentBlock, entryBlock);
    
    currentBlock = entryBlock;
    CExpression testExpr = recurseOnExpression(test);
    flushPostStatements();
    
    Guard ifBranch = Guard.create(testExpr);
    Guard elseBranch = ifBranch.negate();
    
    currentCfg.addEdge(currentBlock, ifBranch, bodyBlock);
    currentCfg.addEdge(currentBlock, elseBranch, loopExitBlock);
    
    currentBlock = bodyBlock;
    dispatch(body);
    currentCfg.addEdge(currentBlock, incrBlock);
    currentBlock = incrBlock;
    dispatch(incr);    

    currentCfg.addEdge(currentBlock, entryBlock);
    currentCfg.addEdge(loopExitBlock, exitBlock);
    
    closeCurrentBlock(entryBlock); // close the loop
    currentBlock = exitBlock;
    popScope();

    if( debugEnabled() ) {
        popAlign();
        debug().decr().flush();
    }   
    exitScope();
  }
}