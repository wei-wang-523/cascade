package edu.nyu.cascade.c;

import java.util.Iterator;

import com.google.common.base.Preconditions;

import xtc.tree.Node;
import xtc.tree.Printer;
import xtc.type.Type;
import xtc.util.SymbolTable.Scope;
import edu.nyu.cascade.c.CAnalyzer;
import edu.nyu.cascade.ir.IRControlFlowGraph;
import edu.nyu.cascade.ir.IRVarInfo;
import edu.nyu.cascade.ir.SymbolTable;
import edu.nyu.cascade.ir.SymbolTableFactory;
import edu.nyu.cascade.ir.impl.VarInfo;
import edu.nyu.cascade.ir.type.IRIntegerType;
import edu.nyu.cascade.util.IOUtils;

/**
 * A decorator around an underlying symbol table that converts the type annotations
 * generated by {@link CAnalyzer} into {@link IRVarInfo}s. The original symbol table
 * is retained and can be retrieved using {@link CSymbolTable#getOriginalSymbolTable()}.
 * It will always have the same current scope as the main symbol table.
 */

public class CSymbolTable implements SymbolTable {
  /*
   * private static class TypeVisitor extends Visitor {
   * 
   * }
   */

/*  public static CascadeSymbolTable create(SymbolTable symbolTable) {
    if( symbolTable instanceof CascadeSymbolTable ) {
      return (CascadeSymbolTable) symbolTable;
    } else {
      return new CascadeSymbolTable(symbolTable);
    }
  }
*/  
  /** Copy the bindings from the given symbol table into a new symbol table. */
  public static CSymbolTable create(SymbolTableFactory factory, xtc.util.SymbolTable xtcSymbolTable) {
    Scope rootScope = xtcSymbolTable.root();
    xtc.util.SymbolTable newXtcSymbolTable = new xtc.util.SymbolTable(rootScope.getName());
    xtcSymbolTable.setScope(rootScope);
    copyScope(xtcSymbolTable, newXtcSymbolTable);
    return new CSymbolTable(factory.create(newXtcSymbolTable), xtcSymbolTable);
  }

  private static void copyScope(xtc.util.SymbolTable xtcSymbolTable, xtc.util.SymbolTable newXtcSymbolTable) {
    Scope scope = xtcSymbolTable.current();
    String scopeName = scope.getName();
    Preconditions.checkArgument(scopeName.equals(newXtcSymbolTable.current().getName()));
    
    IOUtils.debug().pln("Visiting scope: '" + scopeName + "'");
    
    
    /* Rip all the symbols in the scope. */
    Iterator<String> symbolIter = scope.symbols();
    while( symbolIter.hasNext() ) {
      String name = symbolIter.next();
      Object binding = scope.lookupLocally(name);
      assert( binding != null );
      IOUtils.debug().pln("Symbol: '" + name + "'" + " binding: " + binding);
      /* FIXME: Making everything integer, unconditionally. */
      /* FIXME: Using binding as Node as a non-null placeholder. Will binding
       * always be a Node???
       */
      IRVarInfo varInfo = new VarInfo(scope, name,
          IRIntegerType.getInstance(), (Node)binding);
      newXtcSymbolTable.current().define(name, varInfo);
    }
    
    /* Recursively descend through nested scopes. */
    Iterator<String> scopeIter = scope.nested();
    while( scopeIter.hasNext() ) {
      Scope nested = scope.getNested(scopeIter.next() );
      assert( nested != null );
      xtcSymbolTable.enter(nested.getName());    
      newXtcSymbolTable.enter(nested.getName());
      copyScope(xtcSymbolTable, newXtcSymbolTable);
      xtcSymbolTable.exit();
      newXtcSymbolTable.exit();
    }
    
  }
  
  private final SymbolTable symbolTable;
  private final xtc.util.SymbolTable originalSymbolTable;

  CSymbolTable(SymbolTable symbolTable, xtc.util.SymbolTable originalSymbolTable) {
    this.symbolTable = symbolTable;
    this.originalSymbolTable = originalSymbolTable;
  }
  
  @Override
  public void createAndEnterScope(String scopeName, Node node) {
    symbolTable.createAndEnterScope(scopeName, node);
    originalSymbolTable.enter(scopeName);
  }

  @Override
  public void createScope(String scopeName, Node node) {
    symbolTable.createScope(scopeName, node);
    Scope oldScope = originalSymbolTable.current();
    originalSymbolTable.enter(scopeName);
    originalSymbolTable.setScope(oldScope);
  }

  @Override
  public void define(String name, IRVarInfo info) {
    symbolTable.define(name, info);
  }

  @Override
  public void defineLabel(String name, Object def) {
    symbolTable.defineLabel(name, def);
  }

  @Override
  public void enterScope(IRControlFlowGraph cfg) {
    symbolTable.enterScope(cfg);
    Scope scope = cfg.getScope();
    setOriginalScope(scope);
  }

  @Override
  public void enterScope(Node node) {
    symbolTable.enterScope(node);
    Scope currentScope = symbolTable.getCurrentScope();
    setOriginalScope(currentScope);
  }

  @Override
  public void format(Printer printer) {
    symbolTable.format(printer);
  }

  @Override
  public Scope getCurrentScope() {
    return symbolTable.getCurrentScope();
  }

  public xtc.util.SymbolTable getOriginalSymbolTable() {
    return originalSymbolTable;
  }
  
  @Override
  public Scope getScope(Node node) {
    return symbolTable.getScope(node);
  }

  @Override
  public Scope getScope(String id) {
    return symbolTable.getScope(id);
  }

  @Override
  public boolean hasScope(Node node) {
    return symbolTable.hasScope(node);
  }

  @Override
  public boolean isDefined(String name) {
    return symbolTable.isDefined(name);
  }

  @Override
  public boolean isDefined(String name, String namespace) {
    return symbolTable.isDefined(name, namespace);
  }

  @Override
  public boolean labelIsDefined(String name) {
    return symbolTable.labelIsDefined(name);
  }

  /**
   * Overrides the parent implementation to handle XTC-generated bindings, which
   * aren't going to be IRVarInfo's.
   */
  @Override
  public IRVarInfo lookup(String name) {
    return symbolTable.lookup(name);
/*    Scope currentScope = getCurrentScope();
    Object binding = currentScope.lookup(name);
    if (binding instanceof IRVarInfo) {
      return (IRVarInfo) binding;
    } else if (binding instanceof Type) {
      
       * Replace the Type binding with an IRVarInfo TODO: Interpret type and
       * choose appropriate IRType. Non-null source node?S
       
      Scope scope = currentScope.lookupScope(name);
      IRVarInfo varInfo = new VarInfo(scope, name, IRIntegerType.getInstance(),
          null);
      scope.undefine(name);
      scope.define(name, varInfo);
      return varInfo;
    } else {
      throw new UnsupportedOperationException("Unexpected variable binding: "
          + binding);
    }*/
  }

  @Override
  public Scope lookupScope(String name) {
    return symbolTable.lookupScope(name);
  }

  public Object lookupXtcBinding(String name) {
    return getCurrentScope().lookup(name);
  }
  
  @Override
  public String qualify(String parameter) {
    return symbolTable.qualify(parameter);
  }

  @Override
  public Scope rootScope() {
    return symbolTable.rootScope();
  }

  private void setOriginalScope(Scope scope) {
    String qName = scope.getQualifiedName();
    Scope origScope = originalSymbolTable.getScope(qName);
    assert( origScope != null );
    originalSymbolTable.setScope(origScope);
  }
  
  @Override
  public void setScope(Scope scope) {
    symbolTable.setScope(scope);
    setOriginalScope(scope);
  }

  @Override
  public String toLabelName(String name) {
    return symbolTable.toLabelName(name);
  }

  @Override
  public String toNamespace(String name, String namespace) {
    return symbolTable.toNamespace(name, namespace);
  }

  @Override
  public xtc.util.SymbolTable toXtcSymbolTable() {
    return symbolTable.toXtcSymbolTable();
  }

  @Override
  public void undefine(String name) {
    symbolTable.undefine(name);
  }
  
  @Override
  public Type lookupType(String name) {
    return (Type) originalSymbolTable.current().lookup(name);
  }
}
