package edu.nyu.cascade.c;

import java.io.File;
import java.util.Iterator;

import com.google.common.base.Preconditions;

import xtc.tree.Node;
import xtc.tree.Printer;
import xtc.type.Type;
import xtc.util.SymbolTable.Scope;
import edu.nyu.cascade.c.CAnalyzer;
import edu.nyu.cascade.ir.IRControlFlowGraph;
import edu.nyu.cascade.ir.IRVarInfo;
import edu.nyu.cascade.ir.SymbolTable;
import edu.nyu.cascade.ir.SymbolTableFactory;
import edu.nyu.cascade.ir.impl.VarInfoFactory;
import edu.nyu.cascade.util.IOUtils;

/**
 * A decorator around an underlying symbol table that converts the type
 * annotations generated by {@link CAnalyzer} into {@link IRVarInfo}s. The
 * original symbol table is retained and can be retrieved using
 * {@link CSymbolTable#getOriginalSymbolTable()}. It will always have the same
 * current scope as the main symbol table.
 */

public class CSymbolTable implements SymbolTable {
	/** Copy the bindings from the given symbol table into a new symbol table. */
	public static CSymbolTable create(File file, SymbolTableFactory factory,
			xtc.util.SymbolTable xtcSymbolTable) {
		Scope rootScope = xtcSymbolTable.root();
		xtc.util.SymbolTable newXtcSymbolTable = new xtc.util.SymbolTable(
				rootScope.getName());
		xtcSymbolTable.setScope(rootScope);

		if (rootScope.hasNested(CAnalyzer.EXTERN_SCOPE)) {
			xtcSymbolTable.enter(CAnalyzer.EXTERN_SCOPE);
			newXtcSymbolTable.enter(CAnalyzer.EXTERN_SCOPE);
			copyScope(file, xtcSymbolTable, newXtcSymbolTable);
			xtcSymbolTable.exit();
			newXtcSymbolTable.exit();
		}

		copyScope(file, xtcSymbolTable, newXtcSymbolTable);
		return new CSymbolTable(factory.create(newXtcSymbolTable), xtcSymbolTable);
	}

	private static void copyScope(File file, xtc.util.SymbolTable xtcSymbolTable,
			xtc.util.SymbolTable newXtcSymbolTable) {
		Scope scope = xtcSymbolTable.current();
		String scopeName = scope.getQualifiedName();
		Preconditions.checkArgument(
				scopeName.equals(newXtcSymbolTable.current().getQualifiedName()));

		IOUtils.debug().pln("Visiting scope: '" + scopeName + "'");

		/* Rip all the symbols in the scope. */
		Iterator<String> symbolIter = scope.symbols();
		while (symbolIter.hasNext()) {
			String name = symbolIter.next();
			Object binding = scope.lookupLocally(name);
			assert (binding != null);
			IOUtils.debug().pln("Symbol: '" + name + "'" + " binding: " + binding);
			/*
			 * FIXME: Using binding as Node as a non-null placeholder. Will binding
			 * always be a Node???
			 */
			assert (binding instanceof Type);
			IRVarInfo varInfo = VarInfoFactory.createVarInfo(scopeName, name,
					(Type) binding);
			newXtcSymbolTable.current().define(name, varInfo);
		}

		/* Recursively descend through nested scopes. */
		Iterator<String> scopeIter = scope.nested();
		while (scopeIter.hasNext()) {
			Scope nested = scope.getNested(scopeIter.next());
			assert (nested != null);
			xtcSymbolTable.enter(nested.getName());
			newXtcSymbolTable.enter(nested.getName());
			copyScope(file, xtcSymbolTable, newXtcSymbolTable);
			xtcSymbolTable.exit();
			newXtcSymbolTable.exit();
		}
	}

	private final SymbolTable symbolTable;
	private final xtc.util.SymbolTable originalSymbolTable;

	CSymbolTable(SymbolTable symbolTable,
			xtc.util.SymbolTable originalSymbolTable) {
		this.symbolTable = symbolTable;
		this.originalSymbolTable = originalSymbolTable;
	}

	@Override
	public void createAndEnterScope(String scopeName, Node node) {
		symbolTable.createAndEnterScope(scopeName, node);
		originalSymbolTable.enter(scopeName);
	}

	@Override
	public void createScope(String scopeName, Node node) {
		symbolTable.createScope(scopeName, node);
		Scope oldScope = originalSymbolTable.current();
		originalSymbolTable.enter(scopeName);
		originalSymbolTable.setScope(oldScope);
	}

	@Override
	public void define(String name, IRVarInfo info) {
		symbolTable.define(name, info);
	}

	@Override
	public void defineLabel(String name, Object def) {
		symbolTable.defineLabel(name, def);
	}

	@Override
	public void enterScope(IRControlFlowGraph cfg) {
		symbolTable.enterScope(cfg);
		Scope scope = cfg.getScope();
		setOriginalScope(scope);
	}

	@Override
	public void enterScope(Node node) {
		symbolTable.enterScope(node);
		Scope currentScope = symbolTable.getCurrentScope();
		setOriginalScope(currentScope);
	}

	@Override
	public void format(Printer printer) {
		symbolTable.format(printer);
	}

	@Override
	public Scope getCurrentScope() {
		return symbolTable.getCurrentScope();
	}

	@Override
	public xtc.util.SymbolTable getOriginalSymbolTable() {
		return originalSymbolTable;
	}

	@Override
	public Scope getScope(Node node) {
		return symbolTable.getScope(node);
	}

	@Override
	public Scope getScope(String id) {
		return symbolTable.getScope(id);
	}

	@Override
	public boolean hasScope(Node node) {
		return symbolTable.hasScope(node);
	}

	@Override
	public boolean isDefined(String name) {
		return symbolTable.isDefined(name);
	}

	@Override
	public boolean isDefined(String name, String namespace) {
		return symbolTable.isDefined(name, namespace);
	}

	@Override
	public boolean labelIsDefined(String name) {
		return symbolTable.labelIsDefined(name);
	}

	/**
	 * Overrides the parent implementation to handle XTC-generated bindings, which
	 * aren't going to be IRVarInfo's.
	 */
	@Override
	public IRVarInfo lookup(String name) {
		return symbolTable.lookup(name);
		/*
		 * Scope currentScope = getCurrentScope(); Object binding =
		 * currentScope.lookup(name); if (binding instanceof IRVarInfo) { return
		 * (IRVarInfo) binding; } else if (binding instanceof Type) {
		 * 
		 * Replace the Type binding with an IRVarInfo TODO: Interpret type and
		 * choose appropriate IRType. Non-null source node?S
		 * 
		 * Scope scope = currentScope.lookupScope(name); IRVarInfo varInfo = new
		 * VarInfo(scope, name, IRIntegerType.getInstance(), null);
		 * scope.undefine(name); scope.define(name, varInfo); return varInfo; } else
		 * { throw new UnsupportedOperationException("Unexpected variable binding: "
		 * + binding); }
		 */
	}

	@Override
	public Scope lookupScope(String name) {
		return symbolTable.lookupScope(name);
	}

	public Object lookupXtcBinding(String name) {
		return getCurrentScope().lookup(name);
	}

	@Override
	public String qualify(String parameter) {
		return symbolTable.qualify(parameter);
	}

	@Override
	public Scope rootScope() {
		return symbolTable.rootScope();
	}

	private void setOriginalScope(Scope scope) {
		String qName = scope.getQualifiedName();
		Scope origScope = originalSymbolTable.getScope(qName);
		assert (origScope != null);
		originalSymbolTable.setScope(origScope);
	}

	@Override
	public void setScope(Scope scope) {
		symbolTable.setScope(scope);
		setOriginalScope(scope);
	}

	@Override
	public String toLabelName(String name) {
		return symbolTable.toLabelName(name);
	}

	@Override
	public String toNamespace(String name, String namespace) {
		return symbolTable.toNamespace(name, namespace);
	}

	@Override
	public xtc.util.SymbolTable toXtcSymbolTable() {
		return symbolTable.toXtcSymbolTable();
	}

	@Override
	public void undefine(String name) {
		symbolTable.undefine(name);
	}

	@Override
	public void mark(Node node) {
		symbolTable.mark(node);
	}

	@Override
	public Type lookupType(String name) {
		return (Type) originalSymbolTable.current().lookup(name);
	}

	@Override
	public void enter(String name) {
		symbolTable.enter(name);
		originalSymbolTable.enter(name);
	}

	@Override
	public void exit() {
		symbolTable.setScope(getCurrentScope().getParent());
		originalSymbolTable.exit();
	}
}
